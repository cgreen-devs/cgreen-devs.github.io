<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<meta name="author" content="v1.2.0beta">
<title>Cgreen : Unit Tests, Stubbing and Mocking for C and C++</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
body{-webkit-font-smoothing:antialiased}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol,ul.no-bullet,ol.no-bullet{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.no-bullet{list-style:none}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
body{tab-size:4}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menu{color:rgba(0,0,0,.8)}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){.sect1{padding-bottom:1.25em}}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all th.tableblock,table.grid-all td.tableblock{border-width:0 1px 1px 0}
table.grid-all tfoot>tr>th.tableblock,table.grid-all tfoot>tr>td.tableblock{border-width:1px 1px 0 0}
table.grid-cols th.tableblock,table.grid-cols td.tableblock{border-width:0 1px 0 0}
table.grid-all *>tr>.tableblock:last-child,table.grid-cols *>tr>.tableblock:last-child{border-right-width:0}
table.grid-rows th.tableblock,table.grid-rows td.tableblock{border-width:0 0 1px 0}
table.grid-all tbody>tr:last-child>th.tableblock,table.grid-all tbody>tr:last-child>td.tableblock,table.grid-all thead:last-child>tr>th.tableblock,table.grid-rows tbody>tr:last-child>th.tableblock,table.grid-rows tbody>tr:last-child>td.tableblock,table.grid-rows thead:last-child>tr>th.tableblock{border-bottom-width:0}
table.grid-rows tfoot>tr>th.tableblock,table.grid-rows tfoot>tr>td.tableblock{border-width:1px 0 0 0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.unstyled,ol.unnumbered,ul.checklist,ul.none{list-style-type:none}
ul.unstyled,ol.unnumbered,ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1em;font-size:.85em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{width:1em;position:relative;top:1px}
ul.inline{margin:0 auto .625em auto;margin-left:-1.375em;margin-right:0;padding:0;list-style:none;overflow:hidden}
ul.inline>li{list-style:none;float:left;margin-left:1.375em;display:block}
ul.inline>li>*{display:block}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist>table tr>td:first-of-type{padding:0 .75em;line-height:1}
.colist>table tr>td:last-of-type{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;text-indent:-1.05em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.5.0/css/font-awesome.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>Cgreen : Unit Tests, Stubbing and Mocking for C and C++</h1>
<div class="details">
<span id="author" class="author">v1.2.0beta</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="index.html#_cgreen_quickstart_guide">1. Cgreen Quickstart Guide</a>
<ul class="sectlevel2">
<li><a href="index.html#_what_is_cgreen">1.1. What is Cgreen?</a></li>
<li><a href="index.html#_cgreen_vanilla_or_chocolate">1.2. Cgreen - Vanilla or Chocolate?</a></li>
<li><a href="index.html#_installing_cgreen">1.3. Installing Cgreen</a></li>
<li><a href="index.html#tdd_with_cgreen">1.4. Five Minutes Doing TDD with Cgreen</a></li>
<li><a href="index.html#_what_are_mock_functions">1.5. What are Mock Functions?</a></li>
</ul>
</li>
<li><a href="chap1.html#_building_cgreen_test_suites">2. Building Cgreen test suites</a>
<ul class="sectlevel2">
<li><a href="chap1.html#_writing_basic_tests">2.1. Writing Basic Tests</a></li>
<li><a href="chap1.html#_the_standard_constraints">2.2. The Standard Constraints</a></li>
<li><a href="chap1.html#_asserting_c_exceptions">2.3. Asserting C++ Exceptions</a></li>
<li><a href="chap1.html#_bdd_style_vs_tdd_style">2.4. BDD Style vs. TDD Style</a></li>
<li><a href="chap1.html#_legacy_style_assertions">2.5. Legacy Style Assertions</a></li>
<li><a href="chap1.html#_a_runner">2.6. A Runner</a></li>
<li><a href="chap1.html#_beforeeach_and_aftereach">2.7. BeforeEach and AfterEach</a></li>
<li><a href="chap1.html#_each_test_in_its_own_process">2.8. Each Test in its Own Process</a></li>
<li><a href="chap1.html#debugging">2.9. Debugging <strong>Cgreen</strong> tests</a></li>
<li><a href="chap1.html#_building_composite_test_suites">2.10. Building Composite Test Suites</a></li>
</ul>
</li>
<li><a href="#_mocking_functions_with_cgreen">3. Mocking functions with Cgreen</a>
<ul class="sectlevel2">
<li><a href="#_the_problem_with_streams">3.1. The Problem with Streams</a></li>
<li><a href="#_record_and_playback">3.2. Record and Playback</a></li>
<li><a href="#_setting_expectations_on_mock_functions">3.3. Setting Expectations on Mock Functions</a></li>
<li><a href="#_mocks_are">3.4. Mocks Are…​</a></li>
</ul>
</li>
<li><a href="chap3.html#_special_cases">4. Special Cases</a>
<ul class="sectlevel2">
<li><a href="chap3.html#_working_with_code_doubles_code">4.1. Working with <code>doubles</code></a></li>
<li><a href="chap3.html#_using_cgreen_with_c">4.2. Using Cgreen with C++</a></li>
</ul>
</li>
<li><a href="chap4.html#_context_system_under_test_suites">5. Context, System Under Test &amp; Suites</a>
<ul class="sectlevel2">
<li><a href="chap4.html#_the_sut_system_under_test">5.1. The SUT - System Under Test</a></li>
<li><a href="chap4.html#_contexts_and_before_and_after">5.2. Contexts and Before and After</a></li>
</ul>
</li>
<li><a href="chap5.html#auto-discovery">6. Automatic Test Discovery</a>
<ul class="sectlevel2">
<li><a href="chap5.html#_forgot_to_add_your_test">6.1. Forgot to Add Your Test?</a></li>
<li><a href="chap5.html#_the_solution_the_cgreen_runner">6.2. The Solution - the 'cgreen-runner'</a></li>
<li><a href="chap5.html#_using_the_runner">6.3. Using the Runner</a></li>
<li><a href="chap5.html#runner-options">6.4. Cgreen Runner Options</a></li>
<li><a href="chap5.html#_selecting_tests_to_run">6.5. Selecting Tests To Run</a></li>
<li><a href="chap5.html#_multiple_test_libraries">6.6. Multiple Test Libraries</a></li>
<li><a href="chap5.html#_setup_teardown_and_custom_reporters">6.7. Setup, Teardown and Custom Reporters</a></li>
<li><a href="chap5.html#xensure">6.8. Skipping Tests</a></li>
</ul>
</li>
<li><a href="chap6.html#changing_style">7. Changing Style</a></li>
<li><a href="chap7.html#reporter">8. Changing Cgreen Reporting</a>
<ul class="sectlevel2">
<li><a href="chap7.html#_replacing_the_reporter">8.1. Replacing the Reporter</a></li>
<li><a href="chap7.html#builtin_reporters">8.2. Built-in Reporters</a></li>
<li><a href="chap7.html#_rolling_our_own">8.3. Rolling Our Own</a></li>
<li><a href="chap7.html#_the_testreporter_structure">8.4. The TestReporter Structure</a></li>
<li><a href="chap7.html#_an_example_xml_reporter">8.5. An Example XML Reporter</a></li>
</ul>
</li>
<li><a href="chap8.html#_hints_and_tips">9. Hints and Tips</a>
<ul class="sectlevel2">
<li><a href="chap8.html#cgreen-mocker">9.1. <code>cgreen-mocker</code> - Automated Mocking</a></li>
<li><a href="chap8.html#_compiler_error_messages">9.2. Compiler Error Messages</a></li>
<li><a href="chap8.html#_signed_unsigned_hex_and_byte">9.3. Signed, Unsigned, Hex and Byte</a></li>
<li><a href="chap8.html#_cgreen_and_coverage">9.4. Cgreen and Coverage</a></li>
<li><a href="chap8.html#_garbled_output">9.5. Garbled Output</a></li>
</ul>
</li>
<li><a href="chap9.html#_license">Appendix A: License</a></li>
<li><a href="chap10.html#_acknowledgements">Appendix B: Acknowledgements</a></li>
</ul>
</div>
</div>
<div id="content"><div class="sect1">
<h2 id="_mocking_functions_with_cgreen">3. Mocking functions with Cgreen</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When testing you want certainty above all else.  Random events destroy
confidence in your test suite and force needless extra runs &quot;to be
sure&quot;.  A good test places the system under test into a tightly
controlled environment.  A test chamber if you like.  This makes the
tests fast, repeatable and reliable.</p>
</div>
<div class="paragraph">
<p>To create a test chamber for testing code, we have to control any
outgoing calls from the code under test.  We won’t believe our test
failure if our code is making calls to the internet for example.  The
internet can fail all by itself.  Not only do we not have total
control, but it also means we have to get dependent components working
before we can test the higher level code.  This makes it difficult to
code top down.</p>
</div>
<div class="paragraph">
<p>The solution to this dilemma is to write stub code for the components
whilst the higher level code is written.  This pollutes the code base
with temporary code, and the test isolation disappears when the system
is eventually fleshed out.</p>
</div>
<div class="paragraph">
<p>The ideal is to have minimal stubs written for each individual test.
<strong>Cgreen</strong> encourages this approach by making such tests easier to write.</p>
</div>
<div class="sect2">
<h3 id="_the_problem_with_streams">3.1. The Problem with Streams</h3>
<div class="paragraph">
<p>How would we test the following code…​?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">char *read_paragraph(int (*read)(void *), void *stream) {
    int buffer_size = 0, length = 0;
    char *buffer = NULL;
    int ch;
    while ((ch = (*read)(stream)) != EOF) {
        if (++length &gt; buffer_size) {
            buffer_size += 100;
            buffer = (char *)realloc(buffer, buffer_size + 1);
        }
        if ((buffer[length] = ch) == '\n') {
            break;
        }
        buffer[length + 1] = '\0';
    }
    return buffer;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a fairly generic stream filter that turns the incoming
characters into C string paragraphs. Each call creates one paragraph,
returning a pointer to it or returning <code>NULL</code> if there is no
paragraph. The paragraph has memory allocated to it and the stream is
advanced ready for the next call. That’s quite a bit of functionality,
and there are plenty of nasty boundary conditions. I really want this
code tested before I deploy it.</p>
</div>
<div class="paragraph">
<p>The problem is the stream dependency. We could use a real stream, but
that will cause all sorts of headaches. It makes the test of our
paragraph formatter dependent on a working stream.  It means we have
to write the stream first, bottom up coding rather than top down.  It
means we will have to simulate stream failures - not easy.  It will
also mean setting up external resources. This is more work, will run
slower, and could lead to spurious test failures.</p>
</div>
<div class="paragraph">
<p>By contrast, we could write a simulation of the stream for each test,
called a &quot;server stub&quot;.</p>
</div>
<div class="paragraph">
<p>For example, when the stream is empty nothing should happen.  We
hopefully get <code>NULL</code> from <code>read_paragraph</code> when the stream is
exhausted.  That is, it just returns a steady stream of `EOF`s.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">static int empty_stream(void *stream) {
    return EOF;
}

Describe(ParagraphReader);
BeforeEach(ParagraphReader) {}
AfterEach(ParagraphReader) {}

Ensure(ParagraphReader, gives_null_when_reading_empty_stream) {
    assert_that(read_paragraph(&amp;empty_stream, NULL), is_null);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our simulation is easy here, because our fake stream returns only one
value.  Things are harder when the function result changes from call
to call as a real stream would.  Simulating this would mean messing
around with static variables and counters that are reset for each
test.  And of course, we will be writing quite a few stubs. Often a
different one for each test. That’s a lot of clutter.</p>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> can handle this clutter for us by letting us write a single
programmable function for all our tests.</p>
</div>
</div>
<div class="sect2">
<h3 id="_record_and_playback">3.2. Record and Playback</h3>
<div class="paragraph">
<p>We can redo our example by creating a <code>stream_stub()</code> function. We can
call it anything we want, and since I thought we wanted to have a
stubbed stream…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">static int stream_stub(void *stream) {
    return (int)mock(stream);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hardly longer that our trivial server stub above, it is just a macro
to generate a return value, but we can reuse this in test after
test. Let’s see how.</p>
</div>
<div class="paragraph">
<p>For our simple example above we just tell it to always return <code>EOF</code>…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">#include &lt;cgreen/cgreen.h&gt;
#include &lt;cgreen/mocks.h&gt;

char *read_paragraph(int (*read)(void *), void *stream);

static int stream_stub(void *stream) {
    return (int)mock(stream);
}

Describe(ParagraphReader);
BeforeEach(ParagraphReader) {}
AfterEach(ParagraphReader) {}

Ensure(ParagraphReader, gives_null_when_reading_empty_stream) {
    always_expect(stream_stub, will_return(EOF));                                 <i class="conum" data-value="1"></i><b>(1)</b>
    assert_that(read_paragraph(&amp;stream_stub, NULL), is_null);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>always_expect()</code> macro takes as arguments the function
name and defines the return value using the call to
<code>will_return()</code>. This is a declaration of an expectation of a call to
the stub, and we have told our <code>stream_stub()</code> to always return <code>EOF</code>
when called.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Let’s see if our production code actually works…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running &quot;stream&quot; (1 tests)...
  &quot;ParagraphReader&quot;: 1 pass in 42ms.
Completed &quot;stream&quot;: 1 pass in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>So far, so good.  On to the next test.</p>
</div>
<div class="paragraph">
<p>If we want to test a one character line, we have to send the
terminating <code>EOF</code> or <code>&quot;\n&quot;</code> as well as the single character.
Otherwise our code will loop forever, giving an infinite line of that
character.</p>
</div>
<div class="paragraph">
<p>Here is how we can do this…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">Ensure(ParagraphReader, gives_one_character_line_for_one_character_stream) {
    expect(stream_stub, will_return('a'));
    expect(stream_stub, will_return(EOF));
    char *line = read_paragraph(&amp;stream_stub, NULL);
    assert_that(line, is_equal_to_string(&quot;a&quot;));
    free(line);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike the <code>always_expect()</code> instruction, <code>expect()</code> sets up an
expectation of a single call and specifying <code>will_return()</code> sets the
single return value for just that call.  It acts like a record and
playback model.  Successive expectations map out the return sequence
that will be given back once the test proper starts.</p>
</div>
<div class="paragraph">
<p>We’ll add this test to the suite and run it…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running &quot;stream&quot; (2 tests)...
stream_tests.c:23: Failure: ParagraphReader -&gt; gives_one_character_line_for_one_character_stream
    Expected [line] to [equal string] [&quot;a&quot;]
        actual value:			[&quot;¡0@ð&quot;]
        expected to equal:		[&quot;a&quot;]

  &quot;ParagraphReader&quot;: 1 pass, 1 failure in 42ms.
Completed &quot;stream&quot;: 1 pass, 1 failure in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>Oops. Our code under test doesn’t work. Already we need a fix…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">char *read_paragraph(int (*read)(void *), void *stream) {
    int buffer_size = 0, length = 0;
    char *buffer = NULL;
    int ch;
    while ((ch = (*read)(stream)) != EOF) {
        if (++length &gt; buffer_size) {
            buffer_size += 100;
            buffer = (char *)realloc(buffer, buffer_size + 1);
        }
        if ((buffer[length - 1] = ch) == '\n') {              <i class="conum" data-value="1"></i><b>(1)</b>
            break;
        }
        buffer[length] = '\0';                                <i class="conum" data-value="2"></i><b>(2)</b>
    }
    return buffer;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>After moving the indexing here…​</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>and here…​</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>around a bit everything is fine:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running &quot;stream&quot; (2 tests)...
  &quot;ParagraphReader&quot;: 2 passes in 42ms.
Completed &quot;stream&quot;: 2 passes in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>So, how do the <strong>Cgreen</strong> stubs work?  Each <code>expect()</code> describes one
call to the stub and a call to <code>will_return()</code> is included it will
aggregate into a list of return values which are used and returned in
order as the expected calls arrive.</p>
</div>
<div class="paragraph">
<p>The <code>mock()</code> macro captures the parameter names and the <code><em>func</em></code>
property (the name of the stub function).  <strong>Cgreen</strong> can then use these
to look up entries in the return list, and also to generate more
helpful messages.</p>
</div>
<div class="paragraph">
<p>We can now crank out our tests quite quickly…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">Ensure(ParagraphReader, gives_one_word_line_for_one_word_stream) {
    expect(stream_stub, will_return('t'));
    expect(stream_stub, will_return('h'));
    expect(stream_stub, will_return('e'));
    always_expect(stream_stub, will_return(EOF));
    assert_that(read_paragraph(&amp;stream_stub, NULL), is_equal_to_string(&quot;the&quot;));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>I’ve been a bit naughty.  As each test runs in its own process, I
haven’t bothered to free the pointers to the paragraphs.  I’ve just
let the operating system do it.  Purists may want to add the extra
clean up code.</p>
</div>
<div class="paragraph">
<p>I’ve also used <code>always_expect()</code> for the last instruction.  Without
this, if the stub is given an instruction it does not expect, it will
throw a test failure.  This is overly restrictive, as our
<code>read_paragraph()</code> function could quite legitimately call the stream
after it had run off of the end.  OK, that would be odd behaviour, but
that’s not what we are testing here.  If we were, it would be placed
in a test of its own.  The <code>always_expect()</code> call tells <strong>Cgreen</strong> to
keep going after the first three letters, allowing extra calls.</p>
</div>
<div class="paragraph">
<p>As we build more and more tests, they start to look like a
specification of the wanted behaviour…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">Ensure(ParagraphReader, drops_line_ending_from_word_and_stops) {
    expect(stream_stub, will_return('t'));
    expect(stream_stub, will_return('h'));
    expect(stream_stub, will_return('e'));
    expect(stream_stub, will_return('\n'));
    assert_that(read_paragraph(&amp;stream_stub, NULL), is_equal_to_string(&quot;the&quot;));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>…​and just for luck…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">Ensure(ParagraphReader, gives_empty_line_for_single_line_ending) {
    expect(stream_stub, will_return('\n'));
    assert_that(read_paragraph(&amp;stream_stub, NULL), is_equal_to_string(&quot;&quot;));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This time we musn’t use <code>always_return()</code>. We want to leave the stream
where it is, ready for the next call to <code>read_paragraph()</code>. If we call
the stream beyond the line ending, we want to fail.</p>
</div>
<div class="paragraph">
<p>Oops, that was a little too fast. Turns out we are failing anyway…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running &quot;stream&quot; (5 tests)...
stream_tests.c:40: Failure: ParagraphReader -&gt; drops_line_ending_from_word_and_stops
	Expected [read_paragraph(&amp;stream_stub, ((void *)0))] to [equal string] [&quot;the&quot;]
		actual value:			[&quot;the
&quot;]
		expected to equal:		[&quot;the&quot;]

stream_tests.c:45: Failure: ParagraphReader -&gt; gives_empty_line_for_single_line_ending
	Expected [read_paragraph(&amp;stream_stub, ((void *)0))] to [equal string] [&quot;&quot;]
		actual value:			[&quot;
&quot;]
		expected to equal:		[&quot;&quot;]

  &quot;ParagraphReader&quot;: 3 passes, 2 failures in 42ms.
Completed &quot;stream&quot;: 3 passes, 2 failures in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>Clearly we are passing through the line ending.
Another fix later…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">char *read_paragraph(int (*read)(void *), void *stream) {
    int buffer_size = 0, length = 0;
    char *buffer = NULL;
    int ch;
    while ((ch = (*read)(stream)) != EOF) {
        if (++length &gt; buffer_size) {
            buffer_size += 100;
            buffer = (char *)realloc(buffer, buffer_size + 1);
        }
        if ((buffer[length - 1] = ch) == '\n') {
            buffer[--length] = '\0';
            break;
        }
        buffer[length] = '\0';
    }
    return buffer;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And we are passing again…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running &quot;stream&quot; (5 tests)...
  &quot;ParagraphReader&quot;: 5 passes in 42ms.
Completed &quot;stream&quot;: 5 passes in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>There are no limits to the number of stubbed methods within a test,
only that two stubs cannot have the same name. The following will
cause problems…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">static int stream_stub(void *stream) {
    return (int)mock(stream);
}

Ensure(Streams, bad_test) {
    expect(stream_stub, will_return('a'));
    do_stuff(&amp;stream_stub, &amp;stream_stub);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You <em>could</em> program the same stub to return values for the two
streams, but that would make a very brittle test. Since we’d be making
it heavily dependent on the exact internal behaviour that we are
trying to test, or test drive, it will break as soon as we change that
implementation. The test will also become very much harder to read and
understand. And we really don’t want that.</p>
</div>
<div class="paragraph">
<p>So, it will be necessary to have two stubs to make this test behave,
but that’s not a problem…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">static int first_stream_stub(void *stream) {
    return (int)mock(stream);
}

static int second_stream_stub(void *stream) {
    return (int)mock(stream);
}

Ensure(Streams, good_test) {
    expect(first_stream_stub, will_return('a'));
    expect(second_stream_stub, will_return('a'));
    do_stuff(&amp;first_stream_stub, &amp;second_stream_stub);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We now have a way of writing fast, clear tests with no external
dependencies. The information flow is still one way though, from stub
to the code under test. When our code calls complex procedures, we
won’t want to pick apart the effects to infer what happened. That’s
too much like detective work. And why should we? We just want to
know that we dispatched the correct information down the line.</p>
</div>
<div class="paragraph">
<p>Things get more interesting when we think of the traffic going the
other way, from code to stub. This gets us into the same territory as
mock objects.</p>
</div>
</div>
<div class="sect2">
<h3 id="_setting_expectations_on_mock_functions">3.3. Setting Expectations on Mock Functions</h3>
<div class="paragraph">
<p>To swap the traffic flow, we’ll look at an outgoing example instead.
Here is the prewritten production code…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">void by_paragraph(int (*read)(void *), void *in, void (*write)(void *, char *), void *out) {
    while (1) {
        char *line = read_paragraph(read, in);
        if ((line == NULL) || (strlen(line) == 0)) {
            return;
        }
        (*write)(out, line);
        free(line);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the start of a formatter utility.  Later filters will probably
break the paragaphs up into justified text, but right now that is all
abstracted behind the <code>void write(void *, char *)</code> interface.  Our
current interests are: does it loop through the paragraphs, and does
it crash?</p>
</div>
<div class="paragraph">
<p>We could test correct paragraph formation by writing a stub that
collects the paragraphs into a <code>struct</code>.  We could then pick apart
that <code>struct</code> and test each piece with assertions.  This approach is
extremely clumsy in C.  The language is just not suited to building
and tearing down complex edifices, never mind navigating them with
assertions.  We would badly clutter our tests.</p>
</div>
<div class="paragraph">
<p>Instead we’ll test the output as soon as possible, right in
the called function…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">...
void expect_one_letter_paragraph(void *stream, char *paragraph) {
    assert_that(paragraph, is_equal_to_string(&quot;a&quot;));
}

Ensure(Formatter, makes_one_letter_paragraph_from_one_character_input) {
    by_paragraph(
            &amp;one_character_stream,
            NULL,
            &amp;expect_one_letter_paragraph,
            NULL);
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>By placing the assertions into the mocked function, we keep the tests
minimal.  The catch with this method is that we are back to writing
individual functions for each test.  We have the same problem as we
had with hand coded stubs.</p>
</div>
<div class="paragraph">
<p>Again, <strong>Cgreen</strong> has a way to automate this.  Here is the rewritten
test…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">static int reader(void *stream) {
    return (int)mock(stream);
}

static void writer(void *stream, char *paragraph) {
    mock(stream, paragraph);
}

Ensure(Formatter, makes_one_letter_paragraph_from_one_character_input) {
    expect(reader, will_return('a'));
    always_expect(reader, will_return(EOF));
    expect(writer, when(paragraph, is_equal_to_string(&quot;a&quot;)));
    by_paragraph(&amp;reader, NULL, &amp;writer, NULL);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where are the assertions?</p>
</div>
<div class="paragraph">
<p>Unlike our earlier stub, <code>reader()</code> can now check its parameters.  In
object oriented circles, an object that checks its parameters as well
as simulating behaviour is called a mock object.  By analogy
<code>reader()</code> is a mock function, or mock callback.</p>
</div>
<div class="paragraph">
<p>Using the <code>expect</code> macro, we have set up the expectation that
<code>writer()</code> will be called just once.  That call must have the string
<code>&quot;a&quot;</code> for the <code>paragraph</code> parameter.  If the actual value of that
parameter does not match, the mock function will issue a failure
straight to the test suite.  This is what saves us writing a lot of
assertions.</p>
</div>
<div class="paragraph">
<p>When specifying behavior of mocks there are three parts. First, how
often the specified behaviour or expectation will be executed:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Macro</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>expect(function, …​)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Expected once, in order</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>always_expect(function, …​)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Expect this behavior from here onwards</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>never_expect(function)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">From this point this mock function must never be called</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>You can specify constraints and behaviours for each expectation
(except for <code>never_expect()</code> naturally). A constraint places
restrictions on the parameters (and will tell you if the expected
restriction was not met), and a behaviour specifies what the mock
should do if the parameter constraints are met.</p>
</div>
<div class="paragraph">
<p>A parameter constraint is defined using the <code>when(parameter,
constraint)</code> macro. It takes two parameters:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Parameter</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>parameter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the parameter to the mock function</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>constraint</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A constraint placed on that parameter</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>There is a multitude of constraints available (actually, exactly the
same as for the assertions we saw earlier):</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Constraint</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Type</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_greater_than(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_less_than(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to_contents_of(pointer, size_of_contents)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bytes/Structures</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to_contents_of(pointer, size_of_contents)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bytes/Structures</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>contains_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>does_not_contain_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>begins_with_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to_double(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to_double(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_less_than_double(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_greater_than_double(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>For the double valued constraints you can set the number of
significant digits to consider a match with a call to
<code>significant_figures_for_assert_double_are(int figures)</code>.
The <a href="chap3.html#floating_point_comparison_algorithm">section on how to work with doubles</a> has a more detailed
discussion of the algorithm used for comparing floating point numbers.</p>
</div>
<div class="paragraph">
<p>Then there are two ways to return results:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Macro</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>will_return(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Return the value from the mock function (which needs to be declared returning that type</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>will_return_double(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ditto for double values (required because of C’s type coercion rules which would otherwise convert a double into an int)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>will_set_contents_of_parameter(parameter_name, value, size)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Writes the value in the referenced parameter</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>You can combine these in various ways:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">  expect(mocked_file_writer,
        when(data, is_equal_to(42)),
        will_return(EOF));
  expect(mocked_file_reader,
        when(file, is_equal_to_contents_of(&amp;FD, sizeof(FD))),
        when(input, is_equal_to_string(&quot;Hello world!&quot;),
        will_set_contents_of_parameter(status, FD_CLOSED, sizeof(bool))));</code></pre>
</div>
</div>
<div class="paragraph">
<p>If multiple <code>when()</code> are specified they all need to be fullfilled. You
can of course only have one for each of the parameters of your mock
function.</p>
</div>
<div class="paragraph">
<p>You can also have multiple <code>will_set_contents_of_parameter()</code> in an
expectation, one for each reference parameter, but naturally only one
<code>will_return()</code>.</p>
</div>
<div class="paragraph">
<p>It’s about time we actually ran our test…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running &quot;formatter&quot; (1 tests)...
  &quot;Formatter&quot;: 1 pass in 42ms.
Completed &quot;formatter&quot;: 1 pass in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>Confident that a single character works, we can further specify the
behaviour.  Firstly an input sequence…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">Ensure(Formatter, makes_one_paragraph_if_no_line_endings) {
    expect(reader, will_return('a'));
    expect(reader, will_return(' '));
    expect(reader, will_return('b'));
    expect(reader, will_return(' '));
    expect(reader, will_return('c'));
    always_expect(reader, will_return(EOF));
    expect(writer, when(paragraph, is_equal_to_string(&quot;a b c&quot;)));
    by_paragraph(&amp;reader, NULL, &amp;writer, NULL);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A more intelligent programmer than me would place all these calls in a
loop.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running &quot;formatter&quot; (2 tests)...
  &quot;Formatter&quot;: 2 passes in 42ms.
Completed &quot;formatter&quot;: 2 passes in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>Next, checking an output sequence…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">Ensure(Formatter, generates_separate_paragraphs_for_line_endings) {
    expect(reader, will_return('a'));
    expect(reader, will_return('\n'));
    expect(reader, will_return('b'));
    expect(reader, will_return('\n'));
    expect(reader, will_return('c'));
    always_expect(reader, will_return(EOF));
    expect(writer, when(paragraph, is_equal_to_string(&quot;a&quot;)));
    expect(writer, when(paragraph, is_equal_to_string(&quot;b&quot;)));
    expect(writer, when(paragraph, is_equal_to_string(&quot;c&quot;)));
    by_paragraph(&amp;reader, NULL, &amp;writer, NULL);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again we can se that the <code>expect()</code> calls follow a record and playback
model.  Each one tests a successive call.  This sequence confirms that
we get <code>&quot;a&quot;</code>, <code>&quot;b&quot;</code> and <code>&quot;c&quot;</code> in order.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running &quot;formatter&quot; (3 tests)...
  &quot;Formatter&quot;: 5 passes in 42ms.
Completed &quot;formatter&quot;: 5 passes in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>So, why the 5 passes? Each <code>expect()</code> with a constrait is actually
an assert. It asserts that the call specified is actually made with
the parameters given and in the specified order. In this case all the
expected calls were made.</p>
</div>
<div class="paragraph">
<p>Then we’ll make sure the correct stream pointers are passed to the
correct functions.  This is a more realistic parameter check…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">Ensure(Formatter, pairs_the_functions_with_the_resources) {
    expect(reader, when(stream, is_equal_to(1)), will_return('a'));
    always_expect(reader, when(stream, is_equal_to(1)), will_return(EOF));
    expect(writer, when(stream, is_equal_to(2)));
    by_paragraph(&amp;reader, (void *)1, &amp;writer, (void *)2);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>Running &quot;formatter&quot; (4 tests)...
  &quot;Formatter&quot;: 9 passes in 42ms.
Completed &quot;formatter&quot;: 9 passes in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>And finally we’ll specify that the writer is not called if
there is no paragraph.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">Ensure(Formatter, ignores_empty_paragraphs) {
    expect(reader, will_return('\n'));
    always_expect(reader, will_return(EOF));
    never_expect(writer);
    by_paragraph(&amp;reader, NULL, &amp;writer, NULL);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This last test is our undoing…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running &quot;formatter&quot; (5 tests)...
formatter_tests.c:59: Failure: Formatter -&gt; ignores_empty_paragraphs
	Mocked function [writer] has an expectation that it will never be called, but it was

  &quot;Formatter&quot;: 9 passes, 1 failure in 42ms.
Completed &quot;formatter&quot;: 9 passes, 1 failure in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>Obviously blank lines are still being dispatched to the <code>writer()</code>.
Once this is pointed out, the fix is obvious…​</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">void by_paragraph(int (*read)(void *), void *in, void (*write)(void *, char *), void *out) {
    while (1) {
        char *line = read_paragraph(read, in);
        if ((line == NULL) || (strlen(line) == 0)) {
            return;
        }
        (*write)(out, line);
        free(line);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tests with <code>never_expect()</code> can be very effective at uncovering subtle
bugs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running &quot;formatter&quot; (5 tests)...
  &quot;Formatter&quot;: 9 passes in 42ms.
Completed &quot;formatter&quot;: 9 passes in 42ms.</pre>
</div>
</div>
<div class="paragraph">
<p>All done.</p>
</div>
</div>
<div class="sect2">
<h3 id="_mocks_are">3.4. Mocks Are…​</h3>
<div class="paragraph">
<p>Using mocks is a very handy way to isolate a unit by catching and
controlling calls to external units. Depending on your style of coding
two schools of thinking have emerged. And of course <strong>Cgreen</strong> supports
both!</p>
</div>
<div class="sect3">
<h4 id="_strict_or_loose_mocks">3.4.1. Strict or Loose Mocks</h4>
<div class="paragraph">
<p>The two schools are thinking a bit differently about what mock
expectations means. Does it mean that all external calls must be
declared and expected? What happens if a call was made to a mock that
wasn’t expected? And vice versa, if an expected call was not made?</p>
</div>
<div class="paragraph">
<p>Actually, the thinking is not only a school of thought, but you might
want to switch from one to the other. So <strong>Cgreen</strong> allows for that too.</p>
</div>
<div class="paragraph">
<p>By default <strong>Cgreen</strong> mocks are 'strict', which means that a call to
an non-expected mock will be considered a failure. So will an expected
call that was not fullfilled. You might consider this a way to define
a unit through all its exact behaviours towards its neighbours.</p>
</div>
<div class="paragraph">
<p>On the other hand, 'loose' mocks are looser. They allow both
unfulfilled expectations and try to handle unexpected calls in a
reasonable way.</p>
</div>
<div class="paragraph">
<p>You can use both with in the same suite of tests using the call
<code>cgreen_mocks_are(strict_mocks);</code> and <code>cgreen_mocks_are(loose_mocks);</code>
respectively. Typically you would place that call at the beginning of
the test, or in a setup or <code>BeforeEach()</code> if it applies to all tests
in a suite.</p>
</div>
</div>
<div class="sect3">
<h4 id="_learning_mocks">3.4.2. Learning Mocks</h4>
<div class="paragraph">
<p>Working with legacy code and trying to apply TDD, BDD, or even simply
adding some unit tests, is not easy. You’re working with unknown code
that does unknown things with unknown counterparts.</p>
</div>
<div class="paragraph">
<p>So the first step would be to isolate the unit. We won’t go into
details on how to do that here, but basically you would replace the
interface to other units with mocks. This is a somewhat tedious manual
labor, but will result in an isolated unit where you can start
applying your unit tests.</p>
</div>
<div class="paragraph">
<p>Once you have your unit isolated in a harness of mocks, we need to
figure out which calls it does to other units, now replaced by mocks,
in the specific case we are trying to test.</p>
</div>
<div class="paragraph">
<p>This might be complicated, so <strong>Cgreen</strong> makes that a bit simpler. There
is a third 'mode' of the <strong>Cgreen</strong> mocks, the <em>learning mocks</em>.</p>
</div>
<div class="paragraph">
<p>If you temporarily add the call <code>cgreen_mocks_are(learning_mocks);</code> at
the beginning of your unit test, the mocks will record all calls and
present a list of those calls in order, including the actual parameter
values, on the standard output.</p>
</div>
<div class="paragraph">
<p>So let’s look at the following example from the <strong>Cgreen</strong> unit
tests. It’s a bit contorted since the test actually call the mocked
functions directly, but I believe it will serve as an example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c" data-lang="c">static int integer_out() {
    return (int)mock();
}

static char *string_out(int p1) {
    return (char *)mock(p1);
}

Ensure(LearningMocks, emit_pastable_code) {
    cgreen_mocks_are(learning_mocks);
    string_out(1);
    string_out(2);
    integer_out();
    integer_out();
    string_out(3);
    integer_out();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can see the call to <code>cgreen_mocks_are()</code> starting the test and
setting the mocks into learning mode.</p>
</div>
<div class="paragraph">
<p>If we run this, just as we usually run tests, the following will show
up in our terminal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running &quot;learning_mocks&quot; (1 tests)...
LearningMocks -&gt; emit_pastable_code : Learned mocks are
        expect(string_out, when(p1, is_equal_to(1)));
        expect(string_out, when(p1, is_equal_to(2)));
        expect(integer_out);
        expect(integer_out);
        expect(string_out, when(p1, is_equal_to(3)));
        expect(integer_out);
Completed &quot;LearningMocks&quot;: 0 passes, 0 failures, 0 exceptions.
Completed &quot;learning_mocks&quot;: 0 passes, 0 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>If this was for real we could just copy this and paste it in place of
the call to <code>cgreen_mocks_are()</code> and we have all the expectations
done.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Before you can do this you need to implement the mock functions, of
course. I.e. write functions that replaces the real
functions and instead calls <code>mock()</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can try the <code>cgreen-mocker</code> for this, as described in
<a href="chap8.html#cgreen-mocker"><code>cgreen-mocker</code> - Automated Mocking</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div></div>
<div id="footer">
<div id="footer-text">
Last updated 2018-05-10 14:31:17 CEST
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>