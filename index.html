<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="Asciidoctor 0.1.4">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cgreen - Unit Tests for C and C++</title>
<style>
/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
article, aside, details, figcaption, figure, footer, header, hgroup, main, nav, section, summary { display: block; }
audio, canvas, video { display: inline-block; }
audio:not([controls]) { display: none; height: 0; }
[hidden] { display: none; }
html { background: #fff; color: #000; font-family: sans-serif; -ms-text-size-adjust: 100%; -webkit-text-size-adjust: 100%; }
body { margin: 0; }
a:focus { outline: thin dotted; }
a:active, a:hover { outline: 0; }
h1 { font-size: 2em; margin: 0.67em 0; }
abbr[title] { border-bottom: 1px dotted; }
b, strong { font-weight: bold; }
dfn { font-style: italic; }
hr { -moz-box-sizing: content-box; box-sizing: content-box; height: 0; }
mark { background: #ff0; color: #000; }
code, kbd, pre, samp { font-family: monospace, serif; font-size: 1em; }
pre { white-space: pre-wrap; }
q { quotes: "\201C" "\201D" "\2018" "\2019"; }
small { font-size: 80%; }
sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }
img { border: 0; }
svg:not(:root) { overflow: hidden; }
figure { margin: 0; }
fieldset { border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em; }
legend { border: 0; padding: 0; }
button, input, select, textarea { font-family: inherit; font-size: 100%; margin: 0; }
button, input { line-height: normal; }
button, select { text-transform: none; }
button, html input[type="button"], input[type="reset"], input[type="submit"] { -webkit-appearance: button; cursor: pointer; }
button[disabled], html input[disabled] { cursor: default; }
input[type="checkbox"], input[type="radio"] { box-sizing: border-box; padding: 0; }
input[type="search"] { -webkit-appearance: textfield; -moz-box-sizing: content-box; -webkit-box-sizing: content-box; box-sizing: content-box; }
input[type="search"]::-webkit-search-cancel-button, input[type="search"]::-webkit-search-decoration { -webkit-appearance: none; }
button::-moz-focus-inner, input::-moz-focus-inner { border: 0; padding: 0; }
textarea { overflow: auto; vertical-align: top; }
table { border-collapse: collapse; border-spacing: 0; }
*, *:before, *:after { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; }
html, body { font-size: 100%; }
body { background: white; color: #222222; padding: 0; margin: 0; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; line-height: 1; position: relative; cursor: auto; }
a:hover { cursor: pointer; }
a:focus { outline: none; }
img, object, embed { max-width: 100%; height: auto; }
object, embed { height: 100%; }
img { -ms-interpolation-mode: bicubic; }
#map_canvas img, #map_canvas embed, #map_canvas object, .map_canvas img, .map_canvas embed, .map_canvas object { max-width: none !important; }
.left { float: left !important; }
.right { float: right !important; }
.text-left { text-align: left !important; }
.text-right { text-align: right !important; }
.text-center { text-align: center !important; }
.text-justify { text-align: justify !important; }
.hide { display: none; }
.antialiased, body { -webkit-font-smoothing: antialiased; }
img { display: inline-block; vertical-align: middle; }
textarea { height: auto; min-height: 50px; }
select { width: 100%; }
p.lead, .paragraph.lead > p, #preamble > .sectionbody > .paragraph:first-of-type p { font-size: 1.21875em; line-height: 1.6; }
.subheader, #content #toctitle, .admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .videoblock > .title, .listingblock > .title, .literalblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title, .tableblock > caption { line-height: 1.4; color: #7a2518; font-weight: 300; margin-top: 0.2em; margin-bottom: 0.5em; }
div, dl, dt, dd, ul, ol, li, h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6, pre, form, p, blockquote, th, td { margin: 0; padding: 0; direction: ltr; }
a { color: #005498; text-decoration: underline; line-height: inherit; }
a:hover, a:focus { color: #00467f; }
a img { border: none; }
p { font-family: inherit; font-weight: normal; font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; text-rendering: optimizeLegibility; }
p aside { font-size: 0.875em; line-height: 1.35; font-style: italic; }
h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { font-family: Georgia, "URW Bookman L", Helvetica, Arial, sans-serif; font-weight: normal; font-style: normal; color: #ba3925; text-rendering: optimizeLegibility; margin-top: 1em; margin-bottom: 0.5em; line-height: 1.2125em; }
h1 small, h2 small, h3 small, #toctitle small, .sidebarblock > .content > .title small, h4 small, h5 small, h6 small { font-size: 60%; color: #e99b8f; line-height: 0; }
h1 { font-size: 2.125em; }
h2 { font-size: 1.6875em; }
h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.375em; }
h4 { font-size: 1.125em; }
h5 { font-size: 1.125em; }
h6 { font-size: 1em; }
hr { border: solid #dddddd; border-width: 1px 0 0; clear: both; margin: 1.25em 0 1.1875em; height: 0; }
em, i { font-style: italic; line-height: inherit; }
strong, b { font-weight: bold; line-height: inherit; }
small { font-size: 60%; line-height: inherit; }
code { font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; color: #6d180b; }
ul, ol, dl { font-size: 1em; line-height: 1.6; margin-bottom: 1.25em; list-style-position: outside; font-family: inherit; }
ul, ol { margin-left: 1.5em; }
ul li ul, ul li ol { margin-left: 1.25em; margin-bottom: 0; font-size: 1em; }
ul.square li ul, ul.circle li ul, ul.disc li ul { list-style: inherit; }
ul.square { list-style-type: square; }
ul.circle { list-style-type: circle; }
ul.disc { list-style-type: disc; }
ul.no-bullet { list-style: none; }
ol li ul, ol li ol { margin-left: 1.25em; margin-bottom: 0; }
dl dt { margin-bottom: 0.3125em; font-weight: bold; }
dl dd { margin-bottom: 1.25em; }
abbr, acronym { text-transform: uppercase; font-size: 90%; color: #222222; border-bottom: 1px dotted #dddddd; cursor: help; }
abbr { text-transform: none; }
blockquote { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
blockquote cite { display: block; font-size: inherit; color: #555555; }
blockquote cite:before { content: "\2014 \0020"; }
blockquote cite a, blockquote cite a:visited { color: #555555; }
blockquote, blockquote p { line-height: 1.6; color: #6f6f6f; }
.vcard { display: inline-block; margin: 0 0 1.25em 0; border: 1px solid #dddddd; padding: 0.625em 0.75em; }
.vcard li { margin: 0; display: block; }
.vcard .fn { font-weight: bold; font-size: 0.9375em; }
.vevent .summary { font-weight: bold; }
.vevent abbr { cursor: auto; text-decoration: none; font-weight: bold; border: none; padding: 0 0.0625em; }
@media only screen and (min-width: 768px) { h1, h2, h3, #toctitle, .sidebarblock > .content > .title, h4, h5, h6 { line-height: 1.4; }
  h1 { font-size: 2.75em; }
  h2 { font-size: 2.3125em; }
  h3, #toctitle, .sidebarblock > .content > .title { font-size: 1.6875em; }
  h4 { font-size: 1.4375em; } }
.print-only { display: none !important; }
@media print { * { background: transparent !important; color: #000 !important; box-shadow: none !important; text-shadow: none !important; }
  a, a:visited { text-decoration: underline; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; page-break-inside: avoid; }
  thead { display: table-header-group; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page { margin: 0.5cm; }
  p, h2, h3, #toctitle, .sidebarblock > .content > .title { orphans: 3; widows: 3; }
  h2, h3, #toctitle, .sidebarblock > .content > .title { page-break-after: avoid; }
  .hide-on-print { display: none !important; }
  .print-only { display: block !important; }
  .hide-for-print { display: none !important; }
  .show-for-print { display: inherit !important; } }
table { background: white; margin-bottom: 1.25em; border: solid 1px #dddddd; }
table thead, table tfoot { background: whitesmoke; font-weight: bold; }
table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td { padding: 0.5em 0.625em 0.625em; font-size: inherit; color: #222222; text-align: left; }
table tr th, table tr td { padding: 0.5625em 0.625em; font-size: inherit; color: #222222; }
table tr.even, table tr.alt, table tr:nth-of-type(even) { background: #f9f9f9; }
table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td { display: table-cell; line-height: 1.6; }
.clearfix:before, .clearfix:after, .float-group:before, .float-group:after { content: " "; display: table; }
.clearfix:after, .float-group:after { clear: both; }
*:not(pre) > code { font-size: 0.9375em; padding: 1px 3px 0; white-space: nowrap; background-color: #f2f2f2; border: 1px solid #cccccc; -webkit-border-radius: 4px; border-radius: 4px; text-shadow: none; }
pre, pre > code { line-height: 1.4; color: inherit; font-family: Consolas, "Liberation Mono", Courier, monospace; font-weight: normal; }
kbd.keyseq { color: #555555; }
kbd:not(.keyseq) { display: inline-block; color: #222222; font-size: 0.75em; line-height: 1.4; background-color: #F7F7F7; border: 1px solid #ccc; -webkit-border-radius: 3px; border-radius: 3px; -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 0 0 2px white inset; margin: -0.15em 0.15em 0 0.15em; padding: 0.2em 0.6em 0.2em 0.5em; vertical-align: middle; white-space: nowrap; }
kbd kbd:first-child { margin-left: 0; }
kbd kbd:last-child { margin-right: 0; }
.menuseq, .menu { color: #090909; }
p a > code:hover { color: #561309; }
#header, #content, #footnotes, #footer { width: 100%; margin-left: auto; margin-right: auto; margin-top: 0; margin-bottom: 0; max-width: 62.5em; *zoom: 1; position: relative; padding-left: 0.9375em; padding-right: 0.9375em; }
#header:before, #header:after, #content:before, #content:after, #footnotes:before, #footnotes:after, #footer:before, #footer:after { content: " "; display: table; }
#header:after, #content:after, #footnotes:after, #footer:after { clear: both; }
#header { margin-bottom: 2.5em; }
#header > h1 { color: black; font-weight: normal; border-bottom: 1px solid #dddddd; margin-bottom: -28px; padding-bottom: 32px; }
#header span { color: #6f6f6f; }
#header #revnumber { text-transform: capitalize; }
#header br { display: none; }
#header br + span { padding-left: 3px; }
#header br + span:before { content: "\2013 \0020"; }
#header br + span.author { padding-left: 0; }
#header br + span.author:before { content: ", "; }
#toc { border-bottom: 3px double #ebebeb; padding-bottom: 1.25em; }
#toc > ul { margin-left: 0.25em; }
#toc ul.sectlevel0 > li > a { font-style: italic; }
#toc ul.sectlevel0 ul.sectlevel1 { margin-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
#toc ul { list-style-type: none; }
#toctitle { color: #7a2518; }
@media only screen and (min-width: 1280px) { body.toc2 { padding-left: 20em; }
  #toc.toc2 { position: fixed; width: 20em; left: 0; top: 0; border-right: 1px solid #ebebeb; border-bottom: 0; z-index: 1000; padding: 1em; height: 100%; overflow: auto; }
  #toc.toc2 #toctitle { margin-top: 0; }
  #toc.toc2 > ul { font-size: .95em; }
  #toc.toc2 ul ul { margin-left: 0; padding-left: 1.25em; }
  #toc.toc2 ul.sectlevel0 ul.sectlevel1 { padding-left: 0; margin-top: 0.5em; margin-bottom: 0.5em; }
  body.toc2.toc-right { padding-left: 0; padding-right: 20em; }
  body.toc2.toc-right #toc.toc2 { border-right: 0; border-left: 1px solid #ebebeb; left: auto; right: 0; } }
#content #toc { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; border-width: 0; -webkit-border-radius: 4px; border-radius: 4px; }
#content #toc > :first-child { margin-top: 0; }
#content #toc > :last-child { margin-bottom: 0; }
#content #toc a { text-decoration: none; }
#content #toctitle { font-weight: bold; font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif; font-size: 1em; padding-left: 0.125em; }
#footer { max-width: 100%; background-color: #222222; padding: 1.25em; }
#footer-text { color: #dddddd; line-height: 1.44; }
.sect1 { padding-bottom: 1.25em; }
.sect1 + .sect1 { border-top: 3px double #ebebeb; }
#content h1 > a.anchor, h2 > a.anchor, h3 > a.anchor, #toctitle > a.anchor, .sidebarblock > .content > .title > a.anchor, h4 > a.anchor, h5 > a.anchor, h6 > a.anchor { position: absolute; width: 1em; margin-left: -1em; display: block; text-decoration: none; visibility: hidden; text-align: center; font-weight: normal; }
#content h1 > a.anchor:before, h2 > a.anchor:before, h3 > a.anchor:before, #toctitle > a.anchor:before, .sidebarblock > .content > .title > a.anchor:before, h4 > a.anchor:before, h5 > a.anchor:before, h6 > a.anchor:before { content: '\00A7'; font-size: .85em; vertical-align: text-top; display: block; margin-top: 0.05em; }
#content h1:hover > a.anchor, #content h1 > a.anchor:hover, h2:hover > a.anchor, h2 > a.anchor:hover, h3:hover > a.anchor, #toctitle:hover > a.anchor, .sidebarblock > .content > .title:hover > a.anchor, h3 > a.anchor:hover, #toctitle > a.anchor:hover, .sidebarblock > .content > .title > a.anchor:hover, h4:hover > a.anchor, h4 > a.anchor:hover, h5:hover > a.anchor, h5 > a.anchor:hover, h6:hover > a.anchor, h6 > a.anchor:hover { visibility: visible; }
#content h1 > a.link, h2 > a.link, h3 > a.link, #toctitle > a.link, .sidebarblock > .content > .title > a.link, h4 > a.link, h5 > a.link, h6 > a.link { color: #ba3925; text-decoration: none; }
#content h1 > a.link:hover, h2 > a.link:hover, h3 > a.link:hover, #toctitle > a.link:hover, .sidebarblock > .content > .title > a.link:hover, h4 > a.link:hover, h5 > a.link:hover, h6 > a.link:hover { color: #a53221; }
.imageblock, .literalblock, .listingblock, .verseblock, .videoblock { margin-bottom: 1.25em; }
.admonitionblock td.content > .title, .exampleblock > .title, .imageblock > .title, .videoblock > .title, .listingblock > .title, .literalblock > .title, .openblock > .title, .paragraph > .title, .quoteblock > .title, .sidebarblock > .title, .tableblock > .title, .verseblock > .title, .dlist > .title, .olist > .title, .ulist > .title, .qlist > .title, .hdlist > .title { text-align: left; font-weight: bold; }
.tableblock > caption { text-align: left; font-weight: bold; white-space: nowrap; overflow: visible; max-width: 0; }
table.tableblock #preamble > .sectionbody > .paragraph:first-of-type p { font-size: inherit; }
.admonitionblock > table { border: 0; background: none; width: 100%; }
.admonitionblock > table td.icon { text-align: center; width: 80px; }
.admonitionblock > table td.icon img { max-width: none; }
.admonitionblock > table td.icon .title { font-weight: bold; text-transform: uppercase; }
.admonitionblock > table td.content { padding-left: 1.125em; padding-right: 1.25em; border-left: 1px solid #dddddd; color: #6f6f6f; }
.admonitionblock > table td.content > :last-child > :last-child { margin-bottom: 0; }
.exampleblock > .content { border-style: solid; border-width: 1px; border-color: #e6e6e6; margin-bottom: 1.25em; padding: 1.25em; background: white; -webkit-border-radius: 4px; border-radius: 4px; }
.exampleblock > .content > :first-child { margin-top: 0; }
.exampleblock > .content > :last-child { margin-bottom: 0; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6, .exampleblock > .content p { color: #333333; }
.exampleblock > .content h1, .exampleblock > .content h2, .exampleblock > .content h3, .exampleblock > .content #toctitle, .sidebarblock.exampleblock > .content > .title, .exampleblock > .content h4, .exampleblock > .content h5, .exampleblock > .content h6 { line-height: 1; margin-bottom: 0.625em; }
.exampleblock > .content h1.subheader, .exampleblock > .content h2.subheader, .exampleblock > .content h3.subheader, .exampleblock > .content .subheader#toctitle, .sidebarblock.exampleblock > .content > .subheader.title, .exampleblock > .content h4.subheader, .exampleblock > .content h5.subheader, .exampleblock > .content h6.subheader { line-height: 1.4; }
.exampleblock.result > .content { -webkit-box-shadow: 0 1px 8px #d9d9d9; box-shadow: 0 1px 8px #d9d9d9; }
.sidebarblock { border-style: solid; border-width: 1px; border-color: #d9d9d9; margin-bottom: 1.25em; padding: 1.25em; background: #f2f2f2; -webkit-border-radius: 4px; border-radius: 4px; }
.sidebarblock > :first-child { margin-top: 0; }
.sidebarblock > :last-child { margin-bottom: 0; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6, .sidebarblock p { color: #333333; }
.sidebarblock h1, .sidebarblock h2, .sidebarblock h3, .sidebarblock #toctitle, .sidebarblock > .content > .title, .sidebarblock h4, .sidebarblock h5, .sidebarblock h6 { line-height: 1; margin-bottom: 0.625em; }
.sidebarblock h1.subheader, .sidebarblock h2.subheader, .sidebarblock h3.subheader, .sidebarblock .subheader#toctitle, .sidebarblock > .content > .subheader.title, .sidebarblock h4.subheader, .sidebarblock h5.subheader, .sidebarblock h6.subheader { line-height: 1.4; }
.sidebarblock > .content > .title { color: #7a2518; margin-top: 0; line-height: 1.6; }
.exampleblock > .content > :last-child > :last-child, .exampleblock > .content .olist > ol > li:last-child > :last-child, .exampleblock > .content .ulist > ul > li:last-child > :last-child, .exampleblock > .content .qlist > ol > li:last-child > :last-child, .sidebarblock > .content > :last-child > :last-child, .sidebarblock > .content .olist > ol > li:last-child > :last-child, .sidebarblock > .content .ulist > ul > li:last-child > :last-child, .sidebarblock > .content .qlist > ol > li:last-child > :last-child { margin-bottom: 0; }
.literalblock > .content pre, .listingblock > .content pre { background: none; border-width: 1px 0; border-style: dotted; border-color: #bfbfbf; -webkit-border-radius: 4px; border-radius: 4px; padding: 0.75em 0.75em 0.5em 0.75em; word-wrap: break-word; }
.literalblock > .content pre.nowrap, .listingblock > .content pre.nowrap { overflow-x: auto; white-space: pre; word-wrap: normal; }
.literalblock > .content pre > code, .listingblock > .content pre > code { display: block; }
@media only screen { .literalblock > .content pre, .listingblock > .content pre { font-size: 0.8em; } }
@media only screen and (min-width: 768px) { .literalblock > .content pre, .listingblock > .content pre { font-size: 0.9em; } }
@media only screen and (min-width: 1280px) { .literalblock > .content pre, .listingblock > .content pre { font-size: 1em; } }
.listingblock > .content { position: relative; }
.listingblock:hover code[class*=" language-"]:before { text-transform: uppercase; font-size: 0.9em; color: #999; position: absolute; top: 0.375em; right: 0.375em; }
.listingblock:hover code.asciidoc:before { content: "asciidoc"; }
.listingblock:hover code.clojure:before { content: "clojure"; }
.listingblock:hover code.css:before { content: "css"; }
.listingblock:hover code.groovy:before { content: "groovy"; }
.listingblock:hover code.html:before { content: "html"; }
.listingblock:hover code.java:before { content: "java"; }
.listingblock:hover code.javascript:before { content: "javascript"; }
.listingblock:hover code.python:before { content: "python"; }
.listingblock:hover code.ruby:before { content: "ruby"; }
.listingblock:hover code.scss:before { content: "scss"; }
.listingblock:hover code.xml:before { content: "xml"; }
.listingblock:hover code.yaml:before { content: "yaml"; }
.listingblock.terminal pre .command:before { content: attr(data-prompt); padding-right: 0.5em; color: #999; }
.listingblock.terminal pre .command:not([data-prompt]):before { content: '$'; }
table.pyhltable { border: 0; margin-bottom: 0; }
table.pyhltable td { vertical-align: top; padding-top: 0; padding-bottom: 0; }
table.pyhltable td.code { padding-left: .75em; padding-right: 0; }
.highlight.pygments .lineno, table.pyhltable td:not(.code) { color: #999; padding-left: 0; padding-right: .5em; border-right: 1px solid #dddddd; }
.highlight.pygments .lineno { display: inline-block; margin-right: .25em; }
table.pyhltable .linenodiv { background-color: transparent !important; padding-right: 0 !important; }
.quoteblock { margin: 0 0 1.25em; padding: 0.5625em 1.25em 0 1.1875em; border-left: 1px solid #dddddd; }
.quoteblock blockquote { margin: 0 0 1.25em 0; padding: 0 0 0.5625em 0; border: 0; }
.quoteblock blockquote > .paragraph:last-child p { margin-bottom: 0; }
.quoteblock .attribution { margin-top: -.25em; padding-bottom: 0.5625em; font-size: inherit; color: #555555; }
.quoteblock .attribution br { display: none; }
.quoteblock .attribution cite { display: block; margin-bottom: 0.625em; }
table thead th, table tfoot th { font-weight: bold; }
table.tableblock.grid-all { border-collapse: separate; border-spacing: 1px; -webkit-border-radius: 4px; border-radius: 4px; border-top: 1px solid #dddddd; border-bottom: 1px solid #dddddd; }
table.tableblock.frame-topbot, table.tableblock.frame-none { border-left: 0; border-right: 0; }
table.tableblock.frame-sides, table.tableblock.frame-none { border-top: 0; border-bottom: 0; }
table.tableblock td .paragraph:last-child p, table.tableblock td > p:last-child { margin-bottom: 0; }
th.tableblock.halign-left, td.tableblock.halign-left { text-align: left; }
th.tableblock.halign-right, td.tableblock.halign-right { text-align: right; }
th.tableblock.halign-center, td.tableblock.halign-center { text-align: center; }
th.tableblock.valign-top, td.tableblock.valign-top { vertical-align: top; }
th.tableblock.valign-bottom, td.tableblock.valign-bottom { vertical-align: bottom; }
th.tableblock.valign-middle, td.tableblock.valign-middle { vertical-align: middle; }
p.tableblock.header { color: #222222; font-weight: bold; }
td > div.verse { white-space: pre; }
ol { margin-left: 1.75em; }
ul li ol { margin-left: 1.5em; }
dl dd { margin-left: 1.125em; }
dl dd:last-child, dl dd:last-child > :last-child { margin-bottom: 0; }
ol > li p, ul > li p, ul dd, ol dd, .olist .olist, .ulist .ulist, .ulist .olist, .olist .ulist { margin-bottom: 0.625em; }
ul.unstyled, ol.unnumbered, ul.checklist, ul.none { list-style-type: none; }
ul.unstyled, ol.unnumbered, ul.checklist { margin-left: 0.625em; }
ul.checklist li > p:first-child > i[class^="icon-check"]:first-child, ul.checklist li > p:first-child > input[type="checkbox"]:first-child { margin-right: 0.25em; }
ul.checklist li > p:first-child > input[type="checkbox"]:first-child { position: relative; top: 1px; }
ul.inline { margin: 0 auto 0.625em auto; margin-left: -1.375em; margin-right: 0; padding: 0; list-style: none; overflow: hidden; }
ul.inline > li { list-style: none; float: left; margin-left: 1.375em; display: block; }
ul.inline > li > * { display: block; }
.unstyled dl dt { font-weight: normal; font-style: normal; }
ol.arabic { list-style-type: decimal; }
ol.decimal { list-style-type: decimal-leading-zero; }
ol.loweralpha { list-style-type: lower-alpha; }
ol.upperalpha { list-style-type: upper-alpha; }
ol.lowerroman { list-style-type: lower-roman; }
ol.upperroman { list-style-type: upper-roman; }
ol.lowergreek { list-style-type: lower-greek; }
.hdlist > table, .colist > table { border: 0; background: none; }
.hdlist > table > tbody > tr, .colist > table > tbody > tr { background: none; }
td.hdlist1 { padding-right: .8em; font-weight: bold; }
td.hdlist1, td.hdlist2 { vertical-align: top; }
.literalblock + .colist, .listingblock + .colist { margin-top: -0.5em; }
.colist > table tr > td:first-of-type { padding: 0 .8em; line-height: 1; }
.colist > table tr > td:last-of-type { padding: 0.25em 0; }
.qanda > ol > li > p > em:only-child { color: #00467f; }
.thumb, .th { line-height: 0; display: inline-block; border: solid 4px white; -webkit-box-shadow: 0 0 0 1px #dddddd; box-shadow: 0 0 0 1px #dddddd; }
.imageblock.left, .imageblock[style*="float: left"] { margin: 0.25em 0.625em 1.25em 0; }
.imageblock.right, .imageblock[style*="float: right"] { margin: 0.25em 0 1.25em 0.625em; }
.imageblock > .title { margin-bottom: 0; }
.imageblock.thumb, .imageblock.th { border-width: 6px; }
.imageblock.thumb > .title, .imageblock.th > .title { padding: 0 0.125em; }
.image.left, .image.right { margin-top: 0.25em; margin-bottom: 0.25em; display: inline-block; line-height: 0; }
.image.left { margin-right: 0.625em; }
.image.right { margin-left: 0.625em; }
a.image { text-decoration: none; }
span.footnote, span.footnoteref { vertical-align: super; font-size: 0.875em; }
span.footnote a, span.footnoteref a { text-decoration: none; }
#footnotes { padding-top: 0.75em; padding-bottom: 0.75em; margin-bottom: 0.625em; }
#footnotes hr { width: 20%; min-width: 6.25em; margin: -.25em 0 .75em 0; border-width: 1px 0 0 0; }
#footnotes .footnote { padding: 0 0.375em; line-height: 1.3; font-size: 0.875em; margin-left: 1.2em; text-indent: -1.2em; margin-bottom: .2em; }
#footnotes .footnote a:first-of-type { font-weight: bold; text-decoration: none; }
#footnotes .footnote:last-of-type { margin-bottom: 0; }
#content #footnotes { margin-top: -0.625em; margin-bottom: 0; padding: 0.75em 0; }
.gist .file-data > table { border: none; background: #fff; width: 100%; margin-bottom: 0; }
.gist .file-data > table td.line-data { width: 99%; }
div.unbreakable { page-break-inside: avoid; }
.big { font-size: larger; }
.small { font-size: smaller; }
.underline { text-decoration: underline; }
.overline { text-decoration: overline; }
.line-through { text-decoration: line-through; }
.aqua { color: #00bfbf; }
.aqua-background { background-color: #00fafa; }
.black { color: black; }
.black-background { background-color: black; }
.blue { color: #0000bf; }
.blue-background { background-color: #0000fa; }
.fuchsia { color: #bf00bf; }
.fuchsia-background { background-color: #fa00fa; }
.gray { color: #606060; }
.gray-background { background-color: #7d7d7d; }
.green { color: #006000; }
.green-background { background-color: #007d00; }
.lime { color: #00bf00; }
.lime-background { background-color: #00fa00; }
.maroon { color: #600000; }
.maroon-background { background-color: #7d0000; }
.navy { color: #000060; }
.navy-background { background-color: #00007d; }
.olive { color: #606000; }
.olive-background { background-color: #7d7d00; }
.purple { color: #600060; }
.purple-background { background-color: #7d007d; }
.red { color: #bf0000; }
.red-background { background-color: #fa0000; }
.silver { color: #909090; }
.silver-background { background-color: #bcbcbc; }
.teal { color: #006060; }
.teal-background { background-color: #007d7d; }
.white { color: #bfbfbf; }
.white-background { background-color: #fafafa; }
.yellow { color: #bfbf00; }
.yellow-background { background-color: #fafa00; }
span.icon > [class^="icon-"], span.icon > [class*=" icon-"] { cursor: default; }
.admonitionblock td.icon [class^="icon-"]:before { font-size: 2.5em; text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); cursor: default; }
.admonitionblock td.icon .icon-note:before { content: "\f05a"; color: #005498; color: #003f72; }
.admonitionblock td.icon .icon-tip:before { content: "\f0eb"; text-shadow: 1px 1px 2px rgba(155, 155, 0, 0.8); color: #111; }
.admonitionblock td.icon .icon-warning:before { content: "\f071"; color: #bf6900; }
.admonitionblock td.icon .icon-caution:before { content: "\f06d"; color: #bf3400; }
.admonitionblock td.icon .icon-important:before { content: "\f06a"; color: #bf0000; }
.conum { display: inline-block; color: white !important; background-color: #222222; -webkit-border-radius: 100px; border-radius: 100px; text-align: center; width: 20px; height: 20px; font-size: 12px; font-weight: bold; line-height: 20px; font-family: Arial, sans-serif; font-style: normal; position: relative; top: -2px; letter-spacing: -1px; }
.conum * { color: white !important; }
.conum + b { display: none; }
.conum:after { content: attr(data-value); }
.conum:not([data-value]):empty { display: none; }
.literalblock > .content > pre, .listingblock > .content > pre { -webkit-border-radius: 0; border-radius: 0; }

</style>
<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/3.2.1/css/font-awesome.min.css">
<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/7.3/styles/default.min.css">
<script src="http://cdnjs.cloudflare.com/ajax/libs/highlight.js/7.3/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</head>
<body class="article">
<div id="header">
<h1>Cgreen - Unit Tests for C and C++</h1>
<span id="author" class="author">Marcus Baker</span><br>
<span id="email" class="email"><a href="mailto:marcus@lastcraft.com">marcus@lastcraft.com</a></span><br><span id="author2" class="author">Thomas Nilsson</span><br>
<span id="email2" class="email"><a href="mailto:thomas@junovagen.se">thomas@junovagen.se</a></span><br><span id="author3" class="author">Jo√£o Freitas &lt</span><br><span id="author4" class="author">joaohf@gmail.com&gt</span><br>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_cgreen_quickstart_guide">1. Cgreen Quickstart Guide</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_what_is_cgreen">1.1. What is Cgreen?</a></li>
<li><a href="#_cgreen_vanilla_or_chocolate">1.2. Cgreen - Vanilla or Chocolate?</a></li>
<li><a href="#_installing_cgreen">1.3. Installing Cgreen</a></li>
<li><a href="#_five_minutes_doing_tdd_with_cgreen">1.4. Five minutes doing TDD with Cgreen</a></li>
<li><a href="#_what_are_mock_functions">1.5. What are mock functions?</a></li>
</ul>
</li>
<li><a href="#_building_cgreen_test_suites">2. Building Cgreen test suites</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_writing_basic_tests">2.1. Writing basic tests</a></li>
<li><a href="#_bdd_style_vs_tdd_style">2.2. BDD Style vs. TDD Style</a></li>
<li><a href="#_legacy_style_assertions">2.3. Legacy style assertions</a></li>
<li><a href="#_a_runner">2.4. A runner</a></li>
<li><a href="#_beforeeach_and_aftereach">2.5. BeforeEach and AfterEach</a></li>
<li><a href="#_each_test_in_its_own_process">2.6. Each test in its own process</a></li>
<li><a href="#_building_composite_test_suites">2.7. Building composite test suites</a></li>
</ul>
</li>
<li><a href="#_automatic_test_discovery">3. Automatic Test Discovery</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_forgot_to_add_your_test">3.1. Forgot to add your test?</a></li>
<li><a href="#_the_solution_the_em_cgreen_runner_em">3.2. The solution - the <em>cgreen-runner</em></a></li>
<li><a href="#_using_the_runner">3.3. Using the runner</a></li>
<li><a href="#_cgreen_runner_options">3.4. Cgreen Runner Options</a></li>
<li><a href="#_setup_teardown_and_custom_reporters">3.5. Setup, Teardown and custom reporters</a></li>
</ul>
</li>
<li><a href="#_mocking_functions_with_cgreen">4. Mocking functions with Cgreen</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_the_problem_with_streams">4.1. The problem with streams</a></li>
<li><a href="#_record_and_playback">4.2. Record and playback</a></li>
<li><a href="#_setting_expectations_on_mock_functions">4.3. Setting expectations on mock functions</a></li>
<li><a href="#_mocks_are">4.4. Mocks Are&#8230;</a></li>
</ul>
</li>
<li><a href="#_context_subject_under_test_suites">5. Context, Subject Under Test &amp; Suites</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_the_sut_subject_under_test">5.1. The SUT - Subject Under Test</a></li>
<li><a href="#_contexts_and_before_and_after">5.2. Contexts and Before and After</a></li>
</ul>
</li>
<li><a href="#_changing_style">6. Changing Style</a></li>
<li><a href="#_changing_cgreen_reporting">7. Changing Cgreen Reporting</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#_replacing_the_reporter">7.1. Replacing the reporter</a></li>
<li><a href="#_the_testreporter_structure">7.2. The TestReporter structure</a></li>
<li><a href="#_an_example_xml_reporter">7.3. An example XML reporter</a></li>
</ul>
</li>
<li><a href="#_hints_and_tips">8. Hints and Tips</a></li>
<li><a href="#_gnu_free_documentation_license">9. Appendix A: GNU Free Documentation License</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_cgreen_quickstart_guide">1. Cgreen Quickstart Guide</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_what_is_cgreen">1.1. What is Cgreen?</h3>
<div class="paragraph">
<p><strong>Cgreen</strong> is a unit tester for the C and C++ software developer, a test
automation and software quality assurance tool for programmers and
development teams. The tool is completely open source published under
the <a href="http://www.gnu.org/licenses/lgpl.html">LGPL</a></p>
</div>
<div class="paragraph">
<p>Unit testing is a development practice popularised by the agile
development community.  It is characterised by writing many small
tests alongside the normal code. Often the tests are written before
the code they are testing, in a tight test-code-refactor loop.  Done
this way, the practice is known as Test Driven Development. <strong>Cgreen</strong>
was designed to support this style of development.</p>
</div>
<div class="paragraph">
<p>Unit tests are written in the same language as the code, in our case
C or C++. This avoids the mental overhead of constantly switching language,
and also allows you to use any application code in your tests.</p>
</div>
<div class="paragraph">
<p>Here are some of its features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Fluent API resulting in very readable tests</p>
</li>
<li>
<p>Expressive and clear output using the default reporter</p>
</li>
<li>
<p>Extensible reporting mechanism</p>
</li>
<li>
<p>Extensive and expressive constraints for many datatypes</p>
</li>
<li>
<p>Fully composable test suites</p>
</li>
<li>
<p>BDD-flavoured test declarations with Before and After declarations</p>
</li>
<li>
<p>Each test runs in its own process for test suite robustness</p>
</li>
<li>
<p>An isolated test can be run in a single process for debugging</p>
</li>
<li>
<p>Fully functional mocks, both strict and loose</p>
</li>
<li>
<p>Automatic discovery and running of tests using dynamic library inspection</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> also supports the classic xUnit-style assertions for easy
 porting from other frameworks.</p>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> was initially developed to support C programming, but there
is also excellent support for C++. It was initially a spinoff from a
research project at Wordtracker and created by Marcus Baker.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cgreen_vanilla_or_chocolate">1.2. Cgreen - Vanilla or Chocolate?</h3>
<div class="paragraph">
<p>Test driven development (TDD) catched on when the JUnit framework for
Java spread to other langauges, giving us a family of xUnit
tools. <strong>Cgreen</strong> was born in this wave and have many similarities to
the xUnit family.</p>
</div>
<div class="paragraph">
<p>But TDD evolved over time and modern thinking and practice is more
along the lines of BDD, an acronym for Behaviour Driven Development,
made popular by people like Dan North and frameworks like JBehave,
RSpec, Cucumber and Jasmine.</p>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> follows this trend and has evolved to embrace a BDD-flavoured
style of testing. Although the fundamental mechanisms in TDD and BDD
are much the same, the shift in focus by changing wording from <em>tests</em>
to <em>behaviour specifications</em> is very significant.</p>
</div>
<div class="paragraph">
<p>This document will present <strong>Cgreen</strong> using the more modern and better
BDD-style. In a later section you can have a peek at the classic TDD
API.</p>
</div>
</div>
<div class="sect2">
<h3 id="_installing_cgreen">1.3. Installing Cgreen</h3>
<div class="paragraph">
<p>There are two ways to install <strong>Cgreen</strong> in your system.</p>
</div>
<div class="sect3">
<h4 id="_installing_a_package">1.3.1. Installing a package</h4>
<div class="paragraph">
<p>The first way is to use the RPM or DEB package provided by the <strong>Cgreen</strong>
Team. You can fetch it from <a href="http://cgreen.sourceforge.net">Cgreen
website project</a>. Download and install it using the normal procedures
for your system.</p>
</div>
</div>
<div class="sect3">
<h4 id="_installing_from_source">1.3.2. Installing from source</h4>
<div class="paragraph">
<p>The second way is available for developers and advanced
users. Basically this consists of fetching the sources of the project
on <a href="https://github.com/cgreen-devs/cgreen">GitHub</a> and compiling
them. To do this you need the <a href="http://www.cmake.org">CMake</a> build
system.</p>
</div>
<div class="paragraph">
<p>When you have the CMake tool, the steps are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ tar -zxpvf cgreen.tar.gz
$ make
$ make test
$ make install</pre>
</div>
</div>
<div class="paragraph">
<p>The initial <em>make</em> command will configure the build process and
create a separate <code>build</code> directory before going there and building
using <strong>CMake</strong>. This is called an <em>out of source build</em>. It compiles
<strong>Cgreen</strong> from outside the sources directory. This helps the overall
file organization and enables multi-target builds from the same
sources by leaving the complete source tree untouched. The top level
<code>Makefile</code> will by default create the two directories, <code>build/build-c</code>
and <code>build/build-c++</code>, which houses the <em>C</em> and <em>C++</em> builds
respectively.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="icon-tip" title="Tip"></i>
</td>
<td class="content">
Experienced users may tweak the build configurations by going to
the appropriate build subdirectory and use <code>ccmake ../..</code> to modify
the build configuration in that subtree. Creating an extra build
subdirectory with a name starting with <code>build-</code> is also possible. The
<code>Makefile</code> will automatically pick that up and build there too.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The build process will create a library (on unix called
<code>libcgreen.so</code>) which can be used in conjunction with the <code>cgreen.h</code>
header file to compile test code. The created library is installed in
the system, by default in the <code>/usr/local/lib/</code>.</p>
</div>
<div class="paragraph">
<p>We will demonstrate the use of <strong>CGreen</strong> by first writing a test to
confirm everything is working. Let&#8217;s start with a simple test module
with no tests, called <code>first_test.c</code>&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;cgreen/cgreen.h&gt;

Describe(Cgreen);
BeforeEach(Cgreen) {}
AfterEach(Cgreen) {}

int main(int argc, char **argv) {
    TestSuite *suite = create_test_suite();
    return run_test_suite(suite, create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is very unexciting. It just creates an empty test suite
and runs it.  It&#8217;s usually easier to proceed in small steps, though,
and this is the smallest one I could think of. The only complication
is the <code>cgreen.h</code> header file and the mysterious looking
"declarations" at the beginning of the file.</p>
</div>
<div class="paragraph">
<p>The BDD flavoured <strong>Cgreen</strong> notation calls for a Subject Under Test
(SUT), or a <em>context</em>. The declarations give a context to the tests
and it also makes it more natural to talk about which module or class,
the subject under test, is actually responsible for the functionality
we are expressing. In one way we are <em>describing</em>, or spec&#8217;ing, the
functionality of the SUT. That&#8217;s what the <code>Describe();</code> does. And for
technical reasons (actually requirements of the C language), you must
declare the <code>BeforeEach()</code> and <code>AfterEach()</code> functions even if they
are empty. (You will get strange errors if you don&#8217;t!)</p>
</div>
<div class="paragraph">
<p>I am assuming we have the <strong>Cgreen</strong> folder in the include search
path to ensure compilation works, otherwise you&#8217;ll need to add that in
the compilation command.</p>
</div>
<div class="paragraph">
<p>Then, building this test is, of course, trivial&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gcc -c first_test.c
$ gcc first_test.o -lcgreen -o first_test
$ ./first_test</pre>
</div>
</div>
<div class="paragraph">
<p>Invoking the executable should give&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (0 tests)...
Completed "main": 0 passes, 0 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>All of the above rather assumes you are working in a Unix like
environment, probably with <em>gcc</em>. The code is pretty much standard
C99, so any C compiler should work.  <strong>Cgreen</strong> should compile on all
systems that support the <code>sys/msg.h</code> messaging library.  This has been
tested on Linux, MacOSX and Cygwin so far, but not Windows.</p>
</div>
<div class="paragraph">
<p>So far we have tested compilation, and that the test suite actually runs.
Let&#8217;s add a meaningless test or two so that you can see how it runs&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;cgreen/cgreen.h&gt;

Describe(Cgreen);
BeforeEach(Cgreen) {}
AfterEach(Cgreen) {}

Ensure(Cgreen, passes_this_test) {
    assert_that(1 == 1);
}

Ensure(Cgreen, fails_this_test) {
    assert_that(0 == 1);
}

int main(int argc, char **argv) {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, Cgreen, passes_this_test);
    add_test_with_context(suite, Cgreen, fails_this_test);
    return run_test_suite(suite, create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A test is denoted by the macro <code>Ensure</code>. You can think of a test as
having a <code>void (void)</code> signature. You add the test to your suite using
<code>add_test_with_context()</code>.</p>
</div>
<div class="paragraph">
<p>On compiling and running, we now get the output&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (2 tests)...
first_tests.c:12: Failure: fails_this_test
	Expected [0 == 1] to [be true]

Completed "main": 1 pass, 1 failure, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>TextReporter</code>, created by the <code>create_text_reporter()</code> call, is
the easiest way to output the test results. It prints the failures as
intelligent and expressive text messages to your console.</p>
</div>
<div class="paragraph">
<p>Of course "0" would never equal "1", but this shows how <strong>Cgreen</strong>
presents the expression that you want to assert. We can also see a
handy short hand form for boolean expressions (<code>assert_that(1 == 1);</code>).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_five_minutes_doing_tdd_with_cgreen">1.4. Five minutes doing TDD with Cgreen</h3>
<div class="paragraph">
<p>For a more realistic example we need something to test. We&#8217;ll pretend
that we are writing a function to split the words of a sentence in
place. It does this by replacing any spaces with string terminators
and returns the number of conversions plus one.  Here is an example of
what we have in mind&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">char *sentence = strdup("Just the first test");
word_count = split_words(sentence);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>sentence</code> should now point at "Just\0the\0first\0test". Not an
obviously useful function, but we&#8217;ll be using it for something more
practical later.</p>
</div>
<div class="paragraph">
<p>This time around we&#8217;ll add a little more structure to our
tests. Rather than having the test as a stand alone program, we&#8217;ll
separate the runner from the test cases.  That way, multiple test
suites of test cases can be included in the <code>main()</code> runner file.
This makes it less work to add more tests later.</p>
</div>
<div class="paragraph">
<p>Here is the, so far empty, test case in <code>words_test.c</code>&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;cgreen/cgreen.h&gt;
#include &lt;cgreen/mocks.h&gt;

#include "words.h"
#include &lt;string.h&gt;

Describe(Words);
BeforeEach(Words) {}
AfterEach(Words) {}

TestSuite *words_tests() {
    TestSuite *suite = create_test_suite();
    return suite;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is the <code>all_tests.c</code> test runner&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;cgreen/cgreen.h&gt;

TestSuite *words_tests();

int main(int argc, char **argv) {
    TestSuite *suite = create_test_suite();
    add_suite(suite, words_tests());
    if (argc &gt; 1) {
        return run_single_test(suite, argv[1], create_text_reporter());
    }
    return run_test_suite(suite, create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> has two ways of running tests. The default is to run all
tests in their own protected processes. This is what happens if you
invoke <code>run_test_suite()</code>. All tests are then completely independent
since they run in separate processes, preventing a single run-away
test from bringing the whole program down with it. It also ensures
that one test cannot leave any state to the next, thus forcing you to
setup the prerequisites for each test correctly and clearly.</p>
</div>
<div class="paragraph">
<p>But if you want to debug any of your tests the constant <code>fork()ing</code>
can make that difficult or impossible. Cygwin is one example of an
environment where debugging forks might be very hard.</p>
</div>
<div class="paragraph">
<p>To make debugging simpler, <strong>Cgreen</strong> does not fork() when only a single
test is run by name with the function <code>run_single_test()</code>. And if you
want to debug, you can obviously set a breakpoint at that test (but
note that its actual name probably have been mangled). But since
<strong>Cgreen</strong> does some book-keeping before actually getting to the test, a
better function is the one simply called <code>run()</code>.</p>
</div>
<div class="paragraph">
<p>Building this scaffolding&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gcc -c words_test.c
$ gcc -c all_tests.c
$ gcc words_test.o all_tests.o -lcgreen -o all_tests</pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;and executing the result gives the familiar&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (0 tests)...
Completed "words_tests": 0 passes, 0 failures, 0 exceptions.
Completed "main": 0 passes, 0 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>Note that we get an extra level of output here, we have both <code>main</code>
and <code>words_tests</code>. That&#8217;s because <code>all_tests.c</code> adds the words test
suite to its own (named <code>main</code> since it was created in the function
<code>main()</code>). All this scaffolding is pure overhead, but from now on
adding tests will be a lot easier.</p>
</div>
<div class="paragraph">
<p>Here is a first test for <code>split_words()</code> in <code>words_test.c</code>&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;cgreen/cgreen.h&gt;

#include "words.h"
#include &lt;string.h&gt;

Describe(Words);
BeforeEach(Words) {}
AfterEach(Words) {}

Ensure(Words, returns_word_count) {
    char *sentence = strdup("Birds of a feather");
    int word_count = split_words(sentence);
    assert_that(word_count, is_equal_to(4));
    free(sentence);
}

TestSuite *words_tests() {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, Words, returns_word_count);
    return suite;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>assert_that()</code> macro takes two parameters, the value to assert
and a constraint. The constraints comes in various forms. In this case
we use the probably most common, <code>is_equal_to()</code>. With the default
<code>TextReporter</code> the message is sent to <code>STDOUT</code>.</p>
</div>
<div class="paragraph">
<p>To get this to compile we need to create the <code>words.h</code> header file&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">int split_words(char *sentence);</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;and to get the code to link we need a stub function in <code>words.c</code>&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">int split_words(char *sentence) {
    return 0;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A full build later&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gcc -c all_tests.c
$ gcc -c words_test.c
$ gcc -c words.c
$ gcc all_tests.o words_test.o words.o -lcgreen -o all_tests
$ ./all_tests</pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;and we get the more useful response&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (1 tests)...
words_tests.c:13: Failure: words_tests -&gt; returns_word_count
	Expected [word_count] to [equal] [4]
		actual value:			[0]
		expected value:			[4]

Completed "words_tests": 0 passes, 1 failure, 0 exceptions.
Completed "main": 0 passes, 1 failure, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>The breadcrumb trail following the "Failure" text is the nesting of
the tests. It goes from the test suites, which can be nested in each
other, through the test function, and finally to the message from the
assertion. In the language of <strong>Cgreen</strong>, a "failure" is a mismatched
assertion, an "exception" occurs when a test fails to complete for any
reason.</p>
</div>
<div class="paragraph">
<p>We could get this to pass just by returning the value 4. Doing TDD in
really small steps, you would actually do this, but frankly this
example is too simple. Instead we&#8217;ll go straight to the core of the
implementation&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;string.h&gt;

int split_words(char *sentence) {
  int i, count = 1;
  for (i = 0; i &lt; strlen(sentence); i++) {
    if (sentence[i] == ' ') {
      count++;
    }
  }
  return count;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Running it gives&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (1 tests)...
Completed "words_tests": 1 pass, 0 failures, 0 exceptions.
Completed "main": 1 pass, 0 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>There is actually a hidden problem here, but our tests still passed so
we&#8217;ll pretend we didn&#8217;t notice.</p>
</div>
<div class="paragraph">
<p>So it&#8217;s time to add another test. We want to confirm that the string
is broken into separate words&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">...
Ensure(Words, returns_word_count) {
    ...
}

Ensure(Words, converts_spaces_to_zeroes) {
    char *sentence = strdup("Birds of a feather");
    split_words(sentence);
    int comparison = memcmp("Birds\0of\0a\0feather", sentence, strlen(sentence));
    assert_that(comparison, is_equal_to(0));
    free(sentence);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sure enough, we get a failure&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (2 tests)...
words_tests.c:21: Failure: words_tests -&gt; converts_spaces_to_zeroes
	Expected [comparison] to [equal] [0]
		actual value:			[-32]
		expected value:			[0]

Completed "words_tests": 1 pass, 1 failure, 0 exceptions.
Completed "main": 1 pass, 1 failure, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>Not surprising given that we haven&#8217;t written the code yet.</p>
</div>
<div class="paragraph">
<p>The fix&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;string.h&gt;

int split_words(char *sentence) {
  int i, count = 1;
  for (i = 0; i &lt; strlen(sentence); i++) {
    if (sentence[i] == ' ') {
      sentence[i] = '\0';
      count++;
    }
  }
  return count;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;reveals our previous hack&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (2 tests)...
words_tests.c:13: Failure: words_tests -&gt; returns_word_count
	Expected [word_count] to [equal] [4]
		actual value:			[2]
		expected value:			[4]

Completed "words_tests": 1 pass, 1 failure, 0 exceptions.
Completed "main": 1 pass, 1 failure, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>Our earlier test now fails, because we have affected the <code>strlen()</code>
call in our loop.  Moving the length calculation out of the loop&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">int split_words(char *sentence) {
  int i, count = 1, length = strlen(sentence);
  for (i = 0; i &lt; length; i++) {
    ...
  }
  return count;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;restores order&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (2 tests)...
Completed "words_tests": 2 passes, 0 failures, 0 exceptions.
Completed "main": 2 passes, 0 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s nice to keep the code under control while we are actually writing
it, rather than debugging later when things are more complicated.</p>
</div>
<div class="paragraph">
<p>That was pretty straight forward. Let&#8217;s do something more interesting.</p>
</div>
</div>
<div class="sect2">
<h3 id="_what_are_mock_functions">1.5. What are mock functions?</h3>
<div class="paragraph">
<p>The next example is a more realistic extension of our previous
attempts. As in real life we first implement something basic and then
we go for the functionality that we need. In this case a function that
invokes a callback for each word found in a sentence. Something
like&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">void act_on_word(const char *word, void *memo) { ... }
words("This is a sentence", &amp;act_on_word, &amp;memo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here the <code>memo</code> pointer is just some accumulated data that the
<code>act_on_word()</code> callback might work with. Other people will write the
<code>act_on_word()</code> function and probably many other functions like
it. The callback is actually a flex point, and not of interest right
now.</p>
</div>
<div class="paragraph">
<p>The function under test is the <code>words()</code> function and we want to make
sure it walks the sentence correctly, dispatching individual words as
it goes. So what calls are made are very important. How to test this?</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start with a one word sentence. In this case we would expect the
callback to be invoked once with the only word, right? Here is the
test for that&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;cgreen/cgreen.h&gt;
#include &lt;cgreen/mocks.h&gt;
...
void mocked_callback(const char *word, void *memo) {
    mock(word, memo);
}

Ensure(Words, invokes_callback_once_for_single_word_sentence) {
    expect(mocked_callback,
           when(word, is_equal_to_string("Word")), when(memo, is_null));
    words("Word", &amp;mocked_callback, NULL);
}

TestSuite *words_tests() {
    TestSuite *suite = create_test_suite();
    ...
    add_test_with_context(suite, Words, invokes_callback_once_for_single_word_sentence);
    return suite;
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>What is the funny looking <code>mock()</code> function?</p>
</div>
<div class="paragraph">
<p>A mock is basically a programmable object. In C objects are limited to
functions, so this is a mock function. The macro <code>mock()</code> compares the
incoming parameters with any expected values and dispatches messages
to the test suite if there is a mismatch. It also returns any values
that have been preprogrammed in the test.</p>
</div>
<div class="paragraph">
<p>The test function is
<code>invokes_callback_once_for_single_word_sentence()</code>. It programs the
mock function using the <code>expect()</code> macro. It expects a single call,
and that single call should use the parameters "Word" and <code>NULL</code>. If
they don&#8217;t match, we will get a test failure.</p>
</div>
<div class="paragraph">
<p>Of course, we only add the test method, not the mock callback, to the
test suite.</p>
</div>
<div class="paragraph">
<p>For a successful compile and link, the <code>words.h</code> file must now look like&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">int split_words(char *sentence);
void words(const char *sentence, void (*callback)(const char *, void *), void *memo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;and the <code>words.c</code> file should have the stub&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">void words(const char *sentence, void (*callback)(const char *, void *), void *memo) {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This gives us the expected failing test&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (3 tests)...
words_tests.c:33: Failure: words_tests -&gt; invokes_callback_once_for_single_word_sentence
	Expected call was not made to mocked function [mocked_callback]

Completed "words_tests": 2 passes, 1 failure, 0 exceptions.
Completed "main": 2 passes, 1 failure, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> reports that the callback was never invoked. We can easily get
the test to pass by filling out the implementation with&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">void words(const char *sentence, void (*callback)(const char *, void *), void *memo) {
  (*callback)(sentence, memo);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is, we just invoke it once with the whole string. This is a
temporary measure to get us moving. For now everything should pass,
although it doesn&#8217;t drive much functionality yet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (3 tests)...
Completed "words_tests": 4 passes, 0 failures, 0 exceptions.
Completed "main": 4 passes, 0 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>That was all pretty conventional, but let&#8217;s tackle the trickier case
of actually splitting the sentence. Here is the test function we will
add to <code>words_test.c</code>&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">Ensure(Words, invokes_callback_for_each_word_in_a_phrase) {
    expect(mocked_callback, when(word, is_equal_to_string("Birds")));
    expect(mocked_callback, when(word, is_equal_to_string("of")));
    expect(mocked_callback, when(word, is_equal_to_string("a")));
    expect(mocked_callback, when(word, is_equal_to_string("feather")));
    words("Birds of a feather", &amp;mocked_callback, NULL);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each call is expected in sequence. Any failures, or left-over calls,
or extra calls, and we get failures. We can see all this when we run
the tests&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (4 tests)...
words_tests.c:38: Failure: words_tests -&gt; invokes_callback_for_each_word_in_a_phrase
	Expected [[word] parameter in [mocked_callback]] to [equal string] ["Birds"]
		actual value:			["Birds of a feather"]
		expected to equal:		["Birds"]

words_tests.c:39: Failure: words_tests -&gt; invokes_callback_for_each_word_in_a_phrase
	Expected call was not made to mocked function [mocked_callback]

words_tests.c:40: Failure: words_tests -&gt; invokes_callback_for_each_word_in_a_phrase
	Expected call was not made to mocked function [mocked_callback]

words_tests.c:41: Failure: words_tests -&gt; invokes_callback_for_each_word_in_a_phrase
	Expected call was not made to mocked function [mocked_callback]

Completed "words_tests": 4 passes, 4 failures, 0 exceptions.
Completed "main": 4 passes, 4 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>The first failure tells the story. Our little <code>words()</code> function
called the mock callback with the entire sentence. This makes sense,
because that was the hack we did to get to the next test.</p>
</div>
<div class="paragraph">
<p>Although not relevant to this guide, I cannot resist getting these
tests to pass.  Besides, we get to use the function we created
earlier&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">void words(const char *sentence, void (*callback)(const char *, void *), void *memo) {
  char *words = strdup(sentence);
  int word_count = split_words(words);
  char *word = words;
  while (word_count-- &gt; 0) {
    (*callback)(word, memo);
    word = word + strlen(word) + 1;
  }
  free(words);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And with some work we are rewarded with&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (4 tests)...
Completed "words_tests": 8 passes, 0 failures, 0 exceptions.
Completed "main": 8 passes, 0 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>More work than I like to admit as it took me three goes to get this
right. I firstly forgot the <code>+ 1</code> added on to <code>strlen()</code>, then forgot
to swap <code>sentence</code> for <code>word</code> in the <code>(*callback)()</code> call, and finally
third time lucky. Of course running the tests each time made these
mistakes very obvious. It&#8217;s taken me far longer to write these
paragraphs than it has to write the code.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_building_cgreen_test_suites">2. Building Cgreen test suites</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Cgreen</strong> is a tool for building unit tests in the C language. These are
usually written alongside the production code by the programmer to
prevent bugs. Even though the test suites are created by software
developers, they are intended to be human readable C code, as part of
their function is an executable specification.  Used in this way, the
test harness delivers constant quality assurance.</p>
</div>
<div class="paragraph">
<p>In other words you&#8217;ll get less bugs.</p>
</div>
<div class="sect2">
<h3 id="_writing_basic_tests">2.1. Writing basic tests</h3>
<div class="paragraph">
<p><strong>Cgreen</strong> tests are simply C, or C++, functions with no parameters and
no return value. To signal that they actually are tests we mark them
with the <code>Ensure</code> macro. An example might be&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">Ensure(Strlen, returns_five_for_hello) {
    assert_that(strlen("Hello"), is_equal_to(5));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Ensure</code> macro takes two arguments (in the BDD style) where the
first is the Subject Under Test (SUT) which must be declared with the
<code>Describe</code> macro.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">Describe(Strlen);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second argument is the test name and can be anything you want as
long as it fullfills the rules for an identifier in C and C++. A
typical way to choose the named of the tests is what we see here,
reading the declaration of the test makes sense since it is almost
plain english, "Ensure strlen returns five for <em>hello</em>". No problem
understanding what we aim to test. And it can be viewed as an example
from a description of what strlen should be able to do. In a way,
extracting all the <code>Ensure</code>:s from your test might give you all the
documentation you&#8217;ll need.</p>
</div>
<div class="paragraph">
<p>The <code>assert_that()</code> call is the primary part of an assertion, which is
complemented with a constraint, in this case <code>is_equal_to()</code>. This
makes a very fluent interface to the asserts, that actually reads like
English.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
Sometimes you just want to fail the test explicitly, and there is a function for that too, <code>fail_test(const char *message)</code>. And there is a function to explicitly pass, <code>pass_test(void)</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Assertions send messages to <strong>Cgreen</strong>, which in turn outputs the
results.</p>
</div>
<div class="paragraph">
<p>Here are the standard constraints&#8230;</p>
</div>
<table class="tableblock frame-all grid-all" style="width:100%; ">
<colgroup>
<col style="width:50%;">
<col style="width:50%;"> 
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Constraint</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Passes if actual value/expression&#8230;</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_true</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">evaluates to true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_false</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">evaluates to false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">equals null</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_non_null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">is a non null value</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>== value</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>!= value</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_greater_than(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>&gt; value</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_less_than(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>&lt; value</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to_contents_of(pointer, size)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">matches the data pointed to by <code>pointer</code> to a size of <code>size</code> bytes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to_contents_of(pointer, size)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">does not match the data pointed to by <code>pointer</code> to a size of <code>size</code> bytes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">are equal when compared using <code>strcmp()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">are not equal when compared using <code>strcmp()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>contains_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">contains <code>value</code> when evaluated using <code>strstr()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>does_contain_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">does not contain <code>value</code> when evaluated using <code>strstr()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>begins_with_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">starts with the string <code>value</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to_double(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">are equal to <code>value</code> within the number of significant digits (you can set <code>significant_figures_for_assert_double_are(int figures)</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to_double(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">are not equal to <code>value</code> within the number of significant digits</p></td>
</tr>
</tbody>
</table>

<div class="paragraph">
<p>The boolean assertion macros accept an <code>int</code> value. The equality
assertions accept anything that can be cast to <code>intptr_t</code> and simply
perform an <code>==</code> operation. The string comparisons are slightly
different in that they use the <code>&lt;string.h&gt;</code> library function
<code>strcmp()</code>.  If <code>is_equal_to()</code> is used on <code>char *</code> pointers then the
pointers have to point at the same string to pass.</p>
</div>
<div class="paragraph">
<p>A cautionary note about the constraints is that you cannot use C/C++
string literal concatenation (like "don&#8217;t" "use" "string"
"concatenation") in the parameters to the constraints. If you do, you
will get weird error messages about missing arguments to the
constraint macros. This is caused by the macros using argument strings
to produce nice failure messages.</p>
</div>
</div>
<div class="sect2">
<h3 id="_bdd_style_vs_tdd_style">2.2. BDD Style vs. TDD Style</h3>
<div class="paragraph">
<p>So far we have encouraged the modern BDD style. It has merits that we
really want you to benefit from. But you might come across another
style, the standard TDD style, which is more inline with previous
thinking and might be more similar to other frameworks.</p>
</div>
<div class="paragraph">
<p>The only difference, in principle, is the use of the SUT or
<em>context</em>. In the BDD style you have it, in the TDD style you don&#8217;t.</p>
</div>
<div class="listingblock">
<div class="title">BDD style:</div>
<div class="content">
<pre class="highlight"><code class="c language-c">Describe(Strlen);                                                 <i class="conum" data-value="1"></i><b>(1)</b>
BeforeEach(Strlen) {}                                             <i class="conum" data-value="2"></i><b>(2)</b>
AfterEach(Strlen) {}                                              <i class="conum" data-value="3"></i><b>(3)</b>

Ensure(Strlen, returns_five_for_hello) {                          <i class="conum" data-value="4"></i><b>(4)</b>
    assert_that(strlen("Hello"), is_equal_to(5));
}

TestSuite *our_tests() {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, Strlen, returns_five_for_hello); <i class="conum" data-value="5"></i><b>(5)</b>
    return suite;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>Describe</code> macro must name the SUT</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The <code>BeforeEach</code> function&#8230;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230; and the <code>AfterEach</code> functions must exist and name the SUT</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>The test need to name the SUT</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Adding to the test suite</td>
</tr>
</table>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="icon-caution" title="Caution"></i>
</td>
<td class="content">
You can only have tests for a single SUT in the same source file.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you use the older pure-TDD style you skip the <code>Describe</code> macro, the
<code>BeforeEach</code> and <code>AfterEach</code> functions. You don&#8217;t need a SUT in the
<code>Ensure()</code> macro or when you add the test to the suite.</p>
</div>
<div class="listingblock">
<div class="title">TDD style:</div>
<div class="content">
<pre class="highlight"><code class="c language-c">                                                               <i class="conum" data-value="1"></i><b>(1)</b>
Ensure(strlen_returns_five_for_hello) {                        <i class="conum" data-value="2"></i><b>(2)</b>
    assert_that(strlen("Hello"), is_equal_to(5));
}

TestSuite *our_tests() {
    TestSuite *suite = create_test_suite();
    add_test(suite, strlen_returns_five_for_hello);            <i class="conum" data-value="3"></i><b>(3)</b>
    return suite;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>No <code>Describe</code>, <code>BeforeEach()</code> or <code>AfterEach()</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>No SUT/context in the <code>Ensure()</code> macro</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>No SUT/context in <code>add_test()</code> and you should use this function instead
of <code>..with_context()</code>.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="icon-tip" title="Tip"></i>
</td>
<td class="content">
You might think of the TDD style as the BDD style with a default
SUT or context.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_legacy_style_assertions">2.3. Legacy style assertions</h3>
<div class="paragraph">
<p>Cgreen have been around for a while, developed and matured. There is
another style of assertions that was the initial version, a style that
we now call the <em>legacy style</em>, because it was more aligned with the
original, now old, unit test frameworks. If you are not interested in
historical artifacts, I recommend that you skip this section.</p>
</div>
<div class="paragraph">
<p>But for completeness of documentation, here are the legacy style
assertion macros:</p>
</div>
<table class="tableblock frame-all grid-all" style="width:100%; ">
<colgroup>
<col style="width:50%;">
<col style="width:50%;"> 
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Assertion</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_true(boolean)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Passes if boolean evaluates true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_false(boolean)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fails if boolean evaluates true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_equal(first, second)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Passes if <em>first == second</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_not_equal(first, second)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Passes if <em>first != second</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_string_equal(char *, char *)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses <em>strcmp()</em> and passes if the strings are equal</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_string_not_equal(char *, char *)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Uses <em>strcmp()</em> and fails if the strings are equal</p></td>
</tr>
</tbody>
</table>

<div class="paragraph">
<p>Each assertion has a default message comparing the two values. If you
want to substitute your own failure messages, then you must use the
<code>*_with_message()</code> counterparts&#8230;</p>
</div>
<table class="tableblock frame-all grid-all" style="width:100%; ">
<colgroup>
<col style="width:100%;"> 
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Assertion</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_true_with_message(boolean, message, ...)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_false_with_message(boolean, message, ...)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_equal_with_message(tried, expected, message, ...)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_not_equal_with_message(tried, unexpected, message, ...)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_string_equal_with_message(char *, char *, message, ...)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>assert_string_not_equal_with_message(char *, char *, message, ...)</code></p></td>
</tr>
</tbody>
</table>

<div class="paragraph">
<p>All these assertions have an additional <code>char *</code> message parameter,
which is the message you wished to display on failure. If this is set
to <code>NULL</code>, then the default message is shown instead. The most useful
assertion from this group is <code>assert_true_with_message()</code> as you can
use that to create your own assertion functions with your own
messages.</p>
</div>
<div class="paragraph">
<p>Actually the assertion macros have variable argument lists. The
failure message acts like the template in <code>printf()</code>. We could change
the test above to be&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">Ensure(strlen_of_hello_is_five) {
    const char *greeting = "Hello";
    int length = strlen(greeting);
    assert_equal_with_message(length, 5, "[%s] should be 5, but was %d", greeting, length);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This should produce a slightly more user friendly message when things
go wrong. But, actually, Cgreens default messages are so good that you
are encouraged to skip the legacy style and go for the more modern
constraints style assertions. Particularly in conjuction with the BDD
style test notation.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="icon-important" title="Important"></i>
</td>
<td class="content">
We strongly recommend the use of BDD Style notation with
constraints based assertions.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_a_runner">2.4. A runner</h3>
<div class="paragraph">
<p>The tests are only run through running a test suite in some form. We
can create and run one especially for this test like so&#8230; (But see
also <a href="#runner">Automatic Test Discovery</a>.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">TestSuite *our_tests() {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, Strlen, returns_five_for_hello);
    return suite;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In case you have spotted that the reference to
<code>returns_five_for_hello</code> should have an ampersand in front of it,
<code>add_test_with_context()</code> is actually a macro. The <code>&amp;</code> is added
automatically. Further more, the <code>Ensure()</code>-macro actually mangles the
tests name, so it is not actually a function name. (This might also
make them a bit difficult to find in the debugger&#8230;.)</p>
</div>
<div class="paragraph">
<p>To run the test suite, we call <code>run_test_suite()</code> on it. So we can
just write&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">    return run_test_suite(our_tests(), create_text_reporter());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The results of assertions are ultimately delivered as passes and
failures to a collection of callbacks defined in a <code>TestReporter</code>
structure. There is a predefined <code>TestReporter</code> in <strong>Cgreen</strong> called the
<code>TextReporter</code> that delivers messages in plain text like we have
already seen.</p>
</div>
<div class="paragraph">
<p>The return value of <code>run_test_suite()</code> is a standard C library/Unix
exit code that can be returned directly by the <code>main()</code> function.</p>
</div>
<div class="paragraph">
<p>The complete test code now looks like&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;cgreen/cgreen.h&gt;
#include &lt;string.h&gt;

Describe(Strlen);
BeforeEach(Strlen) {}
AfterEach(Strlen) {}

Ensure(Strlen, returns_five_for_hello) {
    assert_that(strlen("Hello"), is_equal_to(5));
}

TestSuite *our_tests() {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, Strlen, returns_five_for_hello);
    return suite;
}

int main(int argc, char **argv) {
    return run_test_suite(our_tests(), create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Compiling and running gives&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gcc -c strlen_test.c
$ gcc strlen_test.o -lcgreen -o strlen_test
$ ./strlen_test
Running "our_tests" (1 tests)...
Completed "our_tests": 1 pass, 0 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>We can see that the outer test suite is called <code>our_tests</code> since it
was in <code>our_tests()</code> we created the test suite. There are no messages
shown unless there are failures. So, let&#8217;s break our test to see it&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">Ensure(Strlen, returns_five_for_hello) {
    assert_that(strlen("Hiya"), is_equal_to(5));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;we&#8217;ll get the helpful message&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "our_tests" (1 tests)...
strlen_tests.c:9: Failure: returns_five_for_hello
	Expected [strlen("Hiya")] to [equal] [5]
		actual value:			[4]
		expected value:			[5]

Completed "our_tests": 0 passes, 1 failure, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> starts every message with the location of the test failure so
that the usual error message identifying tools (like Emacs&#8217;s
<code>next-error</code>) will work out of the box.</p>
</div>
<div class="paragraph">
<p>Once we have a basic test scaffold up, it&#8217;s pretty easy to add more
tests. Adding a test of <code>strlen()</code> with an empty string for example&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">...
Ensure(Strlen, returns_zero_for_empty_string) {
    assert_equal(strlen("\0"), 0);
}

TestSuite *our_tests() {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, Strlen, returns_five_for_hello);
    add_test_with_context(suite, Strlen, returns_zero_for_empty_string);
    return suite;
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>And so on.</p>
</div>
</div>
<div class="sect2">
<h3 id="_beforeeach_and_aftereach">2.5. BeforeEach and AfterEach</h3>
<div class="paragraph">
<p>It&#8217;s common for test suites to have a lot of duplicate code,
especially when setting up similar tests. Take this database code for
example&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;cgreen/cgreen.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;mysql/mysql.h&gt;
#include "person.h"

Describe(Person);
BeforeEach(Person) {}
AfterEach(Person) {}

static void create_schema() {
    MYSQL *connection = mysql_init(NULL);
    mysql_real_connect(connection, "localhost", "me", "secret", "test", 0, NULL, 0);
    mysql_query(connection, "create table people (name, varchar(255) unique)");
    mysql_close(connection);
}

static void drop_schema() {
    MYSQL *connection = mysql_init(NULL);
    mysql_real_connect(connection, "localhost", "me", "secret", "test", 0, NULL, 0);
    mysql_query(connection, "drop table people");
    mysql_close(connection);
}

Ensure(Person, can_add_person_to_database) {
    create_schema();
    Person *person = create_person();
    set_person_name(person, "Fred");
    save_person(person);
    Person *found = find_person_by_name("Fred");
    assert_that(get_person_name(found), is_equal_to_string("Fred"));
    drop_schema();
}

Ensure(Person, cannot_add_duplicate_person) {
    create_schema();
    Person *person = create_person();
    set_person_name(person, "Fred");
    assert_that(save_person(person), is_true);
    Person *duplicate = create_person();
    set_person_name(duplicate, "Fred");
    assert_that(save_person(duplicate), is_false);
    drop_schema();
}

TestSuite *person_tests() {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, Person, can_add_person_to_database);
    add_test_with_context(suite, Person, cannot_add_duplicate_person);
    return suite;
}

int main(int argc, char **argv) {
    return run_test_suite(person_tests(), create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We have already factored out the duplicate code into its own functions
<code>create_schema()</code> and <code>drop_schema()</code>, so things are not so bad. At
least not yet. But what happens when we get dozens of tests? For a
test subject as complicated as a database
<a href="http://www.martinfowler.com/eaaCatalog/activeRecord.html">ActiveRecord</a>,
having dozens of tests is very likely.</p>
</div>
<div class="paragraph">
<p>We can get <strong>Cgreen</strong> to do some of the work for us by calling these
methods before and after each test in the test suite.</p>
</div>
<div class="paragraph">
<p>Here is the new version&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">...
static void create_schema() {
    ...
}

static void drop_schema() {
    ...
}

Describe(Person);
BeforeEach(Person) { create_schema(); }
AfterEach(Person) { drop_schema(); }

Ensure(Person, can_add_person_to_database) {
    Person *person = create_person();
    set_person_name(person, "Fred");
    save_person(person);
    Person *found = find_person_by_name("Fred");
    assert_that(get_person_name(found), is_equal_to_string("Fred"));
}

Ensure(Person, cannot_add_duplicate_person) {
    Person *person = create_person();
    set_person_name(person, "Fred");
    assert_that(save_person(person), is_true);
    Person *duplicate = create_person();
    set_person_name(duplicate, "Fred");
    assert_that(save_person(duplicate), is_false);
}

TestSuite *person_tests() {
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this new arrangement <strong>Cgreen</strong> runs the <code>create_schema()</code> function
before each test, and the <code>drop_schema()</code> function after each
test. This saves some repetitive typing and reduces the chance of
accidents. It also makes the tests more focused.</p>
</div>
<div class="paragraph">
<p>The reason we try so hard to strip everything out of the test
functions is the fact that the test suite acts as documentation. In
our <code>person.h</code> example we can easily see that <code>Person</code> has some kind
of name property, and that this value must be unique. For the tests to
act like a readable specification we have to remove as much mechanical
clutter as we can.</p>
</div>
<div class="paragraph">
<p>In this particular case there are more lines that we could move from
the tests to <code>BeforeEach()</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">    Person *person = create_person();
    set_person_name(person, "Fred");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course that would require an extra variable, and it might make the
tests less clear. And as we add more tests, it might turn out to not
be common to all tests. This is a typical judgement call that you
often get to make with <code>BeforeEach()</code> and <code>AfterEach()</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
if you use the pure-TDD notation, not having the test subject
named by the <code>Describe</code> macro, you can&#8217;t have the <code>BeforeEach()</code> and
<code>AfterEach()</code> either. In this case you can still run a function before
and after every test. Just nominate any <code>void(void)</code> function by
calling the function <code>set_setup()</code> and/or <code>set_teardown()</code> with the
suite and the function that you want to run before/after each test,
e.g. in the example above <code>set_setup(suite, create_schema);</code> and
<code>set_teardown(suite, drop_schema);</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A couple of details. There is only one <code>BeforeEach()</code> and one
<code>AfterEach()</code> allowed in each <code>TestSuite</code>. Also, the <code>AfterEach()</code>
function may not be run if the test crashes, causing some test
interference. This brings us nicely onto the next section&#8230;</p>
</div>
</div>
<div class="sect2">
<h3 id="_each_test_in_its_own_process">2.6. Each test in its own process</h3>
<div class="paragraph">
<p>Consider this test method&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">Ensure(CrashExample, seg_faults_for_null_dereference) {
    int *p = NULL;
    (*p)++;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Crashes are not something you would normally want to have in a test
run. Not least because it will stop you receiving the very test output
you need to tackle the problem.</p>
</div>
<div class="paragraph">
<p>To prevent segmentation faults and other problems bringing down the
test suites, <strong>Cgreen</strong> runs every test in its own process.</p>
</div>
<div class="paragraph">
<p>Just before calling the <code>BeforeEach()</code> (or <code>setup</code>) function, <strong>Cgreen</strong>
<code>fork()</code>:s. The main process waits for the test to complete normally
or die. This includes the calling the <code>AfterEach()</code>(or <code>teardown</code>)
function, if any. If the test process dies, an exception is reported
and the main test process carries on.</p>
</div>
<div class="paragraph">
<p>For example&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;cgreen/cgreen.h&gt;
#include &lt;stdlib.h&gt;

Describe(CrashExample);
BeforeEach(CrashExample) {}
AfterEach(CrashExample) {}

Ensure(CrashExample, seg_faults_for_null_dereference) {
    int *p = NULL;
    (*p)++;
}

int main(int argc, char **argv) {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, CrashExample, seg_faults_for_null_dereference);
    return run_test_suite(suite, create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When built and run, this gives&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (1 tests)...
crash_tests.c:8: Exception: seg_faults_for_null_dereference
	Test terminated with signal: Segmentation fault

Completed "main": 0 passes, 0 failures, 1 exception.</pre>
</div>
</div>
<div class="paragraph">
<p>The obvious thing to do now is to fire up the debugger. Unfortunately,
the constant <code>fork()</code>:ing of <strong>Cgreen</strong> can be an extra complication too
many when debugging. It&#8217;s enough of a problem to find the bug.</p>
</div>
<div class="paragraph">
<p>To get around this, and also to allow the running of one test at a
time, <strong>Cgreen</strong> has the <code>run_single_test()</code> function. The signatures of
the two run methods are&#8230;</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>int run_test_suite(TestSuite *suite, TestReporter *reporter);</code></p>
</li>
<li>
<p><code>int run_single_test(TestSuite *suite, char *test, TestReporter *reporter);</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The extra parameter of <code>run_single_test()</code>, the <code>test</code> string, is the
name of the test to select.  This could be any test, even in nested
test suites (see below). Here is how we would use it to debug our
crashing test&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">int main(int argc, char **argv) {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, CrashExample, seg_faults_for_null_dereference);
    return run_single_test(suite, "seg_faults_for_null_dereference", create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When run in this way, <strong>Cgreen</strong> will not <code>fork()</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="icon-tip" title="Tip"></i>
</td>
<td class="content">
The function <code>run()</code> is a good place to place a breakpoint.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following is a typical session:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gdb crash2
...
(gdb) break main
(gdb) run
...
(gdb) break run
(gdb) continue
...
Running "main" (1 tests)...

Breakpoint 2, run_the_test_code (suite=suite@entry=0x2003abb0,
    spec=spec@entry=0x402020 &lt;CgreenSpec__CrashExample__seg_faults_for_null_dereference__&gt;,
    reporter=reporter@entry=0x2003abe0) at /cygdrive/c/Users/Thomas/Utveckling/Cgreen/cgreen/src/runner.c:270
270         run(spec);
(gdb) step
run (spec=0x402020 &lt;CgreenSpec__CrashExample__seg_faults_for_null_dereference__&gt;)
    at /cygdrive/c/Users/Thomas/Utveckling/Cgreen/cgreen/src/runner.c:217
217             spec-&gt;run();
(gdb) step
CrashExample__seg_faults_for_null_dereference () at crash_test2.c:9
9           int *p = NULL;
(gdb) step
10          (*p)++;
(gdb) step

Program received signal SIGSEGV, Segmentation fault.
0x004011ea in CrashExample__seg_faults_for_null_dereference () at crash_test2.c:10
10          (*p)++;</pre>
</div>
</div>
<div class="paragraph">
<p>Which shows exactly where the problem is.</p>
</div>
<div class="paragraph">
<p>This deals with the case where your code throws an exception like
segmentation fault, but what about a process that fails to complete by
getting stuck in a loop?</p>
</div>
<div class="paragraph">
<p>Well, <strong>Cgreen</strong> will wait forever too. But, using the C signal
handlers, we can place a time limit on the process by sending it an
interrupt. To save us writing this ourselves, <strong>Cgreen</strong> includes the
<code>die_in()</code> function to help us out.</p>
</div>
<div class="paragraph">
<p>Here is an example of time limiting a test&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">...
Ensure(CrashExample, seg_faults_for_null_dereference) {
    ...
}

Ensure(CrashExample, will_loop_forever) {
    die_in(1);
    while(0 == 0) { }
}

int main(int argc, char **argv) {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, CrashExample, seg_faults_for_null_dereference);
    add_test_with_context(suite, CrashExample, will_loop_forever);
    return run_test_suite(suite, create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When executed, the code will slow for a second, and then finish with&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "main" (2 tests)...
crash_tests.c:8: Exception: seg_faults_for_null_dereference
	Test terminated with signal: Segmentation fault

crash_tests.c:13: Exception: will_loop_forever
	Test terminated unexpectedly, likely from a non-standard exception or Posix signal

Completed "main": 0 passes, 0 failures, 2 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>Note that you see the test results as they come in. <strong>Cgreen</strong> streams the
results as they happen, making it easier to figure out where the test
suite has problems.</p>
</div>
<div class="paragraph">
<p>Of course, if you want to set a general time limit on all your tests,
then you can add a <code>die_in()</code> to a <code>BeforeEach()</code> (or <code>setup()</code>)
function. <strong>Cgreen</strong> will then apply the limit to each of the tests, of
course.</p>
</div>
</div>
<div class="sect2">
<h3 id="_building_composite_test_suites">2.7. Building composite test suites</h3>
<div class="paragraph">
<p>The <code>TestSuite</code> is a composite structure.  This means test suites can
be added to test suites, building a tree structure that will be
executed in order.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s combine the <code>strlen()</code> tests with the <code>Person</code> tests above.
Firstly we need to remove the <code>main()</code> calls.  E.g&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">Ensure(Strlen, returns_five_for_hello) {
   ...
}

Ensure(Strlen, returns_zero_for_empty_string) {
   ...
}

TestSuite *our_tests() {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, Strlen, returns_five_for_hello);
    add_test_with_context(suite, Strlen, returns_zero_for_empty_string);
    return suite;
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we can write a small runner with a new <code>main()</code> function&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;cgreen/cgreen.h&gt;

TestSuite *our_tests();
TestSuite *person_tests();

int main(int argc, char **argv) {
    TestSuite *suite = create_test_suite();
    add_suite(suite, our_tests());
    add_suite(suite, person_tests());
    if (argc &gt; 1) {
        return run_single_test(suite, argv[1], create_text_reporter());
    }
    return run_test_suite(suite, create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s usually easier to place the <code>TestSuite</code> prototypes directly in
the runner source, rather than have lot&#8217;s of header files.  This is
the same reasoning that let us drop the prototypes for the test
functions in the actual test scripts.  We can get away with this,
because the tests are more about documentation than encapsulation.</p>
</div>
<div class="paragraph">
<p>As we saw above, we can run a single test using the
<code>run_single_test()</code> function, and we&#8217;d like to be able to do that from
the command line. So we added a simple <code>if</code> block to take the test
name as an optional argument.  The entire test suite will be searched
for the named test.  This trick also saves us a recompile when we
debug.</p>
</div>
<div class="paragraph">
<p>When you use the BDD notation you can only have a single test subject
(which is actually equivalent of a suite) in a single file because you
can only have one <code>Describe()</code> macro in each file. But using this
strategy you can create composite suites that takes all your tests and
run them in one go.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="icon-caution" title="Caution"></i>
</td>
<td class="content">
Rewrite pending. The next couple section does not reflect the
current best thinking. They are remnants of the TDD notation. Using
BDD notation you would create separate contexts, each in its own file,
with separate names, for each of the fixture cases.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
If you use the TDD (non-BDD) notation you can build several test
suites in the same file, even nesting them.  We can even add mixtures
of test functions and test suites to the same parent test suite.
Loops will give trouble, however.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
If we do place several suites in the same file, then all the suites
will be named the same in the breadcrumb trail in the test message.
They will all be named after the function the create call sits in.  If
you want to get around this, or you just like to name your test
suites, you can use <code>create_named_test_suite()</code> instead of
<code>create_test_suite()</code>.  This takes a single string parameter.  In fact
<code>create_test_suite()</code> is just a macro that inserts the <code>__func__</code>
constant into <code>create_named_test_suite()</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>What happens to <code>setup</code> and <code>teardown</code> functions in a <code>TestSuite</code> that
contains other `TestSuite`s?</p>
</div>
<div class="paragraph">
<p>Well firstly, <strong>Cgreen</strong> does not <code>fork()</code> when running a suite.  It
leaves it up to the child suite to <code>fork()</code> the individual tests.
This means that a <code>setup</code> and <code>teardown</code> will run in the main
process.  They will be run once for each child suite.</p>
</div>
<div class="paragraph">
<p>We can use this to speed up our <code>Person</code> tests above.  Remember we
were creating a new connection and closing it again in the fixtures.
This means opening and closing a lot of connections.  At the slight
risk of some test interference, we could reuse the connection accross
tests&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">...
static MYSQL *connection;

static void create_schema() {
    mysql_query(connection, "create table people (name, varchar(255) unique)");
}

static void drop_schema() {
    mysql_query(connection, "drop table people");
}

Ensure(can_add_person_to_database) { ... }
Ensure(cannot_add_duplicate_person) { ... }

void open_connection() {
    connection = mysql_init(NULL);
    mysql_real_connect(connection, "localhost", "me", "secret", "test", 0, NULL, 0);
}

void close_connection() {
    mysql_close(connection);
}

TestSuite *person_tests() {
    TestSuite *suite = create_test_suite();
    set_setup(suite, create_schema);
    set_teardown(suite, drop_schema);
    add_test(suite, can_add_person_to_database);
    add_test(suite, cannot_add_duplicate_person);

    TestSuite *fixture = create_named_test_suite("Mysql fixture");
    add_suite(fixture, suite);
    set_setup(fixture, open_connection);
    set_teardown(fixture, close_connection);
    return fixture;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The trick here is creating a test suite as a wrapper whose sole
purpose to wrap the main test suite in the fixture.  This is our
<em>fixture</em> pointer.  This code is a little confusing, because we have
two sets of fixtures in the same test script.</p>
</div>
<div class="paragraph">
<p>We have the MySQL connection fixture.  This is runs
<code>open_connection()</code> and <code>close_connection()</code> just once at the
beginning and end of the person tests.  This is because the <code>suite</code>
pointer is the only member of <code>fixture</code>.</p>
</div>
<div class="paragraph">
<p>We also have the schema fixture, the <code>create_schema()</code> and
<code>drop_schema()</code>, which is run before and after every test.  Those are
still attached to the inner <code>suite</code>.</p>
</div>
<div class="paragraph">
<p>In the real world we would probably place the connection
fixture in its own file&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">static MYSQL *connection;

MYSQL *get_connection() {
    return connection;
}

static void open_connection() {
    connection = mysql_init(NULL);
    mysql_real_connect(connection, "localhost", "me", "secret", "test", 0, NULL, 0);
}

static void close_connection() {
    mysql_close(connection);
}

TestSuite *connection_fixture(TestSuite *suite) {
    TestSuite *fixture = create_named_test_suite("Mysql fixture");
    add_suite(fixture, suite);
    set_setup(fixture, open_connection);
    set_teardown(fixture, close_connection);
    return fixture;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This allows the reuse of common fixtures across projects.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_automatic_test_discovery">3. Automatic Test Discovery</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_forgot_to_add_your_test">3.1. Forgot to add your test?</h3>
<div class="paragraph">
<p>When we write a new test we focus on the details about the test we are
trying to write. And writing tests is no trivial matter so this might
well take a lot of brain power.</p>
</div>
<div class="paragraph">
<p>So, it comes as no big surprise, that sometimes you write your test
and then forget to add it to the suite. When we run it it appears that it
passed on the first try! Although this <strong>should</strong> really make you
suspicious, sometimes you get so happy that you just continue with
churning out more tests and more code. It&#8217;s not until some (possibly
looong) time later that you realize, after much headache and
debugging, that the test did not actually pass. It was never even run!</p>
</div>
<div class="paragraph">
<p>There are practices to minimize the risk of this happening, such as
always running the test as soon as you can set up the test. This way
you will see it fail before trying to get it to pass.</p>
</div>
<div class="paragraph">
<p>But it is still a practice, something we, as humans, might fail to do
at some point. Usually this happens when we are most stressed and in
need of certainty.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_solution_the_em_cgreen_runner_em">3.2. The solution - the <em>cgreen-runner</em></h3>
<div class="paragraph">
<p><strong>Cgreen</strong> gives you a tool to avoid not only the risk of this
happening, but also the extra work and extra code. It is called the
<code>cgreen-runner</code>.</p>
</div>
<div class="paragraph">
<p>The <code>cgreen-runner</code> should come with your <strong>Cgreen</strong> installation if
your platform supports the technique that is required, which is
<em>programatic access to dynamic loading of libraries</em>. This means
that a program can load an external library of code into memory and
inspect it. Kind of self-inspection, or reflexion.</p>
</div>
<div class="paragraph">
<p>So all you have to do is to build a dynamically loadable library of
all tests (and of course your objects under test and other necessary
code). Then you can run the <code>cgreen-runner</code> and point it to the
library. The runner will then load the library, enumerate all tests in
it, and run every test.</p>
</div>
<div class="paragraph">
<p>It&#8217;s automatic, and there is nothing to forget.</p>
</div>
</div>
<div class="sect2">
<h3 id="_using_the_runner">3.3. Using the runner</h3>
<div class="paragraph">
<p>Assuming your tests are in <code>first_test.c</code> the typical command to
build your library using <code>gcc</code> would be</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gcc -shared -o first_test.so -fPIC first_test.c -lcgreen</pre>
</div>
</div>
<div class="paragraph">
<p>The <code>-fPIC</code> means to generate <em>position independent code</em> which is
required if you want to load the library dynamically.</p>
</div>
<div class="paragraph">
<p>How to build a dynamically loadable shared library might vary a lot
depending on your platform. Can&#8217;t really help you there, sorry!</p>
</div>
<div class="paragraph">
<p>As soon as we have linked it we can run the tests using the
<code>cgreen-runner</code> by just giving it the shared, dynamic loadable, object
library as an argument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cgreen-runner first_test.so
Running "first_tests" (2 tests)...
first_tests.c:12: Failure: Cgreen -&gt; fails_this_test
	Expected [0 == 1] to [be true]

Completed "Cgreen": 1 pass, 1 failure, 0 exceptions.
Completed "first_tests": 1 pass, 1 failure, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>More or less exactly the same output as when we ran our first test in
the beginning of this quickstart tutorial. We can see that the top
level of the tests will be named as the library it was discovered in,
and the second level is the context for our Subject Under Test, in
this case <em>Cgreen</em>. We also see that the context is mentioned in the
failure message, giving a fairly obvious <em>Cgreen &#8594; fails_this_test</em>.</p>
</div>
<div class="paragraph">
<p>Now we can actually delete the main function in our source code. We
don&#8217;t need all this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">int main(int argc, char **argv) {
    TestSuite *suite = create_test_suite();
    add_test_with_context(suite, Cgreen, passes_this_test);
    add_test_with_context(suite, Cgreen, fails_this_test);
    return run_test_suite(suite, create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It always feel good to delete code, right?</p>
</div>
<div class="paragraph">
<p>We can also select which test to run:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cgreen-runner first_test.so Cgreen:this_test_should_fail
Running "first_tests" (1 tests)...
first_tests.c:12: Failure: Cgreen -&gt; fails_this_test
	Expected [0 == 1] to [be true]

Completed "Cgreen": 0 passes, 1 failure, 0 exceptions.
Completed "first_tests": 0 passes, 1 failure, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>As the runner requires the BDD notation to discover tests, we also
need to indicate which context the test we want to run is in. In this
case <code>Cgreen</code> so the test should be refered to as
<code>Cgreen:this_test_should_fail</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_cgreen_runner_options">3.4. Cgreen Runner Options</h3>
<div class="paragraph">
<p>Once you get the build set up right for the cgreen-runner everything
is fairly straight-forward. But you have a few options:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">--xml &lt;prefix&gt;</dt>
<dd>
<p>Instead of messages on stdout with the TextReporter,
  write results into one XML-file per suite or context,
compatible with Hudson/Jenkins CI. The filename(s)
will be <code>&lt;prefix&gt;-&lt;suite&gt;.xml</code></p>
</dd>
<dt class="hdlist1">--suite &lt;name&gt;</dt>
<dd>
<p>Name the top level suite</p>
</dd>
<dt class="hdlist1">--no-run</dt>
<dd>
<p>Don&#8217;t run the tests</p>
</dd>
<dt class="hdlist1">--verbose</dt>
<dd>
<p>Show progress information and list discovered tests</p>
</dd>
<dt class="hdlist1">--colours</dt>
<dd>
<p>Use colours (or colors) to emphasis result (requires ANSI-capable terminal)</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The <code>verbose</code> option is particularly handy since it will give you the
actual names of all tests discovered. That means if you have long test
names you can avoid mistyping them by copy and paste from the output
of <code>cgreen-runner --verbose</code>. It will also give the mangled name of
the test which should make it easier to find in the debugger. Here&#8217;s
an example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Discovered Cgreen:fails_this_test (Cgreen__fails_this_test)
Discovered Cgreen:passes_this_test (Cgreen__passes_this_test)
Discovered 2 test(s)
Opening [first_tests.so] to only run one test: 'Cgreen:fails_this_test' ...
Running "first_tests" (1 tests)...
first_tests.c:12: Failure: Cgreen -&gt; fails_this_test
	Expected [0 == 1] to [be true]

Completed "Cgreen": 0 passes, 1 failure, 0 exceptions.
Completed "first_tests": 0 passes, 1 failure, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>You can also run tests in multiple libraries in one go by adding them
to the <code>cgreen-runner</code> command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ cgreen-runner first_set.so second_set.so ...</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_setup_teardown_and_custom_reporters">3.5. Setup, Teardown and custom reporters</h3>
<div class="paragraph">
<p>The cgreen-runner will only run setup and teardown functions if you
use the BDD-ish style with <code>BeforeEach()</code> and <code>AfterEach()</code> as
described above. The runner does not pickup <code>setup()</code> and <code>teardown()</code>
added to suites, because it actually doesn&#8217;t run suites. It discovers
all tests and runs them one by one. The macros required by the BDD-ish
style ensures that the corresponding <code>BeforeEach()</code> and <code>AfterEach()</code>
are run before and after each test.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
The <code>cgreen-runner</code> <em>will</em> discover your tests in a shared library
even if you don&#8217;t use the BDD-ish style. But it will not run the
<code>setup()</code> and/or <code>teardown()</code> attached to your suite(s). But in case
you have non-BDD style tests <em>without</em> any <code>setup()</code> and/or
<code>teardown()</code> you can still use the runner. The default suite/context
where the tests live in this case is called <code>default</code>. But why don&#8217;t
you convert your tests to BDD notation? This would save you from the
frustrating trouble-shooting that you risk when you added <code>setup()</code>
and <code>teardown()</code> and can&#8217;t understand why they are not run&#8230;
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>So, the runner requires you to use the BDD notation. But since we
recommend that you do anyway, that&#8217;s no extra problem if you are
starting out from scratch. But see <a href="#changing_style">Changing Style</a>
for some easy tips on how to get you there if you already have non-BDD
tests.</p>
</div>
<div class="paragraph">
<p>You can choose between the TextReporter, which we have been seeing so
far, and the built-in JUnit/Ant compatible XML-reporter using the
<code>--xml</code> option. But, it is not possible to use custom reporters as
outlined in <a href="#reporter">Changing Cgreen Reporting</a> with the runner.</p>
</div>
<div class="paragraph">
<p>If you require another custom reporter you need to resort to the
standard, programatic, way of invoking your tests. For now&#8230;</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mocking_functions_with_cgreen">4. Mocking functions with Cgreen</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When testing you want certainty above all else.  Random events destroy
confidence in your test suite and force needless extra runs "to be
sure".  A good test places the subject under test into a tightly
controlled environment.  A test chamber if you like.  This makes the
tests fast, repeatable and reliable.</p>
</div>
<div class="paragraph">
<p>To create a test chamber for testing code, we have to control any
outgoing calls from the code under test.  We won&#8217;t believe our test
failure if our code is making calls to the internet for example.  The
internet can fail all by itself.  Not only do we not have total
control, but it means we have to get dependent components working
before we can test the higher level code.  This makes it difficult to
code top down.</p>
</div>
<div class="paragraph">
<p>The solution to this dilemma is to write stub code for the components
whilst the higher level code is written.  This pollutes the code base
with temporary code, and the test isolation disappears when the system
is eventually fleshed out.</p>
</div>
<div class="paragraph">
<p>The ideal is to have minimal stubs written for each individual test.
<strong>Cgreen</strong> encourages this approach by making such tests easier to write.</p>
</div>
<div class="sect2">
<h3 id="_the_problem_with_streams">4.1. The problem with streams</h3>
<div class="paragraph">
<p>How would we test this code&#8230;?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">char *read_paragraph(int (*read)(void *), void *stream) {
    int buffer_size = 0, length = 0;
    char *buffer = NULL;
    int ch;
    while ((ch = (*read)(stream)) != EOF) {
        if (++length &gt; buffer_size) {
            buffer_size += 100;
            buffer = (char *)realloc(buffer, buffer_size + 1);
        }
        if ((buffer[length] = ch) == '\n') {
            break;
        }
        buffer[length + 1] = '\0';
    }
    return buffer;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a fairly generic stream filter that turns the incoming
characters into C string paragraphs. Each call creates one paragraph,
returning a pointer to it or returning <code>NULL</code> if there is no
paragraph. The paragraph has memory allocated to it and the stream is
advanced ready for the next call. That&#8217;s quite a bit of functionality,
and there are plenty of nasty boundary conditions. I really want this
code tested before I deploy it.</p>
</div>
<div class="paragraph">
<p>The problem is the stream dependency. We could use a real stream, but
that will cause all sorts of headaches. It makes the test of our
paragraph formatter dependent on a working stream.  It means we have
to write the stream first, bottom up coding rather than top down.  It
means we will have to simulate stream failures - not easy.  It will
also mean setting up external resources. This is more work, will run
slower, and could lead to spurious test failures.</p>
</div>
<div class="paragraph">
<p>By contrast, we could write a simulation of the stream for each test,
called a "server stub".</p>
</div>
<div class="paragraph">
<p>For example, when the stream is empty nothing should happen.  We
hopefully get <code>NULL</code> from <code>read_paragraph</code> when the stream is
exhausted.  That is, it just returns a steady stream of `EOF`s.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">static int empty_stream(void *stream) {
    return EOF;
}

Describe(ParagraphReader);
BeforeEach(ParagraphReader) {}
AfterEach(ParagraphReader) {}

Ensure(ParagraphReader, gives_null_when_reading_empty_stream) {
    assert_that(read_paragraph(&amp;empty_stream, NULL), is_null);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Our simulation is easy here, because our fake stream returns only one
value.  Things are harder when the function result changes from call
to call as a real stream would.  Simulating this would mean messing
around with static variables and counters that are reset for each
test.  And of course, we will be writing quite a few stubs. Often a
different one for each test. That&#8217;s a lot of clutter.</p>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> can handle this clutter for us by letting us write a single
programmable function for all our tests.</p>
</div>
</div>
<div class="sect2">
<h3 id="_record_and_playback">4.2. Record and playback</h3>
<div class="paragraph">
<p>We can redo our example by creating a <code>stream_stub()</code> function. We can
call it anything we want, and since I thought we wanted to have a
stubbed stream&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">static int stream_stub(void *stream) {
    return (int)mock(stream);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hardly longer that our trivial server stub above, it is just a macro
to generate a return value, but we can reuse this in test after
test. Let&#8217;s see how.</p>
</div>
<div class="paragraph">
<p>For our simple example above we just tell it to always return <code>EOF</code>&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;cgreen/cgreen.h&gt;
#include &lt;cgreen/mocks.h&gt;

char *read_paragraph(int (*read)(void *), void *stream);

static int stream_stub(void *stream) {
    return (int)mock(stream);
}

Describe(ParagraphReader);
BeforeEach(ParagraphReader) {}
AfterEach(ParagraphReader) {}

Ensure(ParagraphReader, gives_null_when_reading_empty_stream) {
    always_expect(stream_stub, will_return(EOF));                                 <i class="conum" data-value="1"></i><b>(1)</b>
    assert_that(read_paragraph(&amp;stream_stub, NULL), is_null);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>always_expect()</code> macro at (1) takes as arguments the function
name and defines the return value using the call to
<code>will_return()</code>. This is a declaration of an expectation of a call to
the stub, and we have told our <code>stream_stub()</code> to always return <code>EOF</code>
when called.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see if our production code actually works&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "stream" (1 tests)...
Completed "ParagraphReader": 1 pass, 0 failures, 0 exceptions.
Completed "stream": 1 pass, 0 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>So far, so good.  On to the next test.</p>
</div>
<div class="paragraph">
<p>If we want to test a one character line, we have to send the
terminating <code>EOF</code> or <code>"\n"</code> as well as the single character.
Otherwise our code will loop forever, giving an infinite line of that
character.</p>
</div>
<div class="paragraph">
<p>Here is how we can do this&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">Ensure(ParagraphReader, gives_one_character_line_for_one_character_stream) {
    expect(stream_stub, will_return('a'));
    expect(stream_stub, will_return(EOF));
    char *line = read_paragraph(&amp;stream_stub, NULL);
    assert_that(line, is_equal_to_string("a"));
    free(line);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike the <code>always_expect()</code> instruction, <code>expect()</code> sets up an
expectation of a single call and specifying <code>will_return()</code> sets the
single return value for just that call.  It acts like a record and
playback model.  Successive expectations map out the return sequence
that will be given back once the test proper starts.</p>
</div>
<div class="paragraph">
<p>We&#8217;ll add this test to the suite and run it&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "stream" (2 tests)...
stream_tests.c:23: Failure: ParagraphReader -&gt; gives_one_character_line_for_one_character_stream
	Expected [line] to [equal string] ["a"]
		actual value:			["xa"]
		expected to equal:		["a"]

Completed "ParagraphReader": 1 pass, 1 failure, 0 exceptions.
Completed "stream": 1 pass, 1 failure, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>Oops. Our code under test doesn&#8217;t work. Already we need a fix&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">char *read_paragraph(int (*read)(void *), void *stream) {
    int buffer_size = 0, length = 0;
    char *buffer = NULL;
    int ch;
    while ((ch = (*read)(stream)) != EOF) {
        if (++length &gt; buffer_size) {
            buffer_size += 100;
            buffer = (char *)realloc(buffer, buffer_size + 1);
        }
        if ((buffer[length - 1] = ch) == '\n') {
            break;
        }
        buffer[length] = '\0';
    }
    return buffer;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>After which everything is fine&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "stream" (2 tests)...
Completed "ParagraphReader": 2 passes, 0 failures, 0 exceptions.
Completed "stream": 2 passes, 0 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>How do the <strong>Cgreen</strong> stubs work?  Each <code>expect()</code> describes one call to
the stub and the calls to <code>will_return()</code> build up a static list of
return values which are used and returned in order as those calls
arrive. The return values are cleared between tests.</p>
</div>
<div class="paragraph">
<p>The <code>mock()</code> macro captures the parameter names and the <code>__func__</code>
property (the name of the stub function).  <strong>Cgreen</strong> can then use these
to look up entries in the return list, and also to generate more
helpful messages.</p>
</div>
<div class="paragraph">
<p>We can crank out our tests quite quickly now&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">Ensure(ParagraphReader, gives_one_word_line_for_one_word_stream) {
    expect(stream_stub, will_return('t'));
    expect(stream_stub, will_return('h'));
    expect(stream_stub, will_return('e'));
    always_expect(stream_stub, will_return(EOF));
    assert_that(read_paragraph(&amp;stream_stub, NULL), is_equal_to_string("the"));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>I&#8217;ve been a bit naughty.  As each test runs in its own process, I
haven&#8217;t bothered to free the pointers to the paragraphs.  I&#8217;ve just
let the operating system do it.  Purists may want to add the extra
clean up code.</p>
</div>
<div class="paragraph">
<p>I&#8217;ve also used <code>always_expect()</code> for the last instruction.  Without
this, if the stub is given an instruction it does not expect, it will
throw a test failure.  This is overly restrictive, as our
<code>read_paragraph()</code> function could quite legitimately call the stream
after it had run off of the end.  OK, that would be odd behaviour, but
that&#8217;s not what we are testing here.  If we were, it would be placed
in a test of its own.  The <code>always_expect()</code> call tells <strong>Cgreen</strong> to
keep going after the first three letters, allowing extra calls.</p>
</div>
<div class="paragraph">
<p>As we build more and more tests, they start to look like a
specification of the wanted behaviour&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">Ensure(ParagraphReader, drops_line_ending_from_word_and_stops) {
    expect(stream_stub, will_return('t'));
    expect(stream_stub, will_return('h'));
    expect(stream_stub, will_return('e'));
    expect(stream_stub, will_return('\n'));
    assert_that(read_paragraph(&amp;stream_stub, NULL), is_equal_to_string("the"));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;and just for luck&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">Ensure(ParagraphReader, gives_empty_line_for_single_line_ending) {
    expect(stream_stub, will_return('\n'));
    assert_that(read_paragraph(&amp;stream_stub, NULL), is_equal_to_string(""));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This time we musn&#8217;t use <code>always_return()</code>. We want to leave the stream
where it is, ready for the next call to <code>read_paragraph()</code>. If we call
the stream beyond the line ending, we want to fail.</p>
</div>
<div class="paragraph">
<p>Oops, that was a little too fast. Turns out we are failing anyway&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "stream"" (5 tests)...
stream_tests.c:40: Failure: ParagraphReader -&gt; drops_line_ending_from_word_and_stops
	Expected [read_paragraph(&amp;stream_stub, ((void *)0))] to [equal string] ["the"]
		actual value:			["the
"]
		expected to equal:		["the"]

stream_tests.c:45: Failure: ParagraphReader -&gt; gives_empty_line_for_single_line_ending
	Expected [read_paragraph(&amp;stream_stub, ((void *)0))] to [equal string] [""]
		actual value:			["
"]
		expected to equal:		[""]

Completed "ParagraphReader": 3 passes, 2 failures, 0 exceptions.
Completed "stream"": 3 passes, 2 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>Clearly we are passing through the line ending.
Another fix later&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">char *read_paragraph(int (*read)(void *), void *stream) {
    int buffer_size = 0, length = 0;
    char *buffer = NULL;
    int ch;
    while ((ch = (*read)(stream)) != EOF) {
        if (++length &gt; buffer_size) {
            buffer_size += 100;
            buffer = (char *)realloc(buffer, buffer_size + 1);
        }
        if ((buffer[length - 1] = ch) == '\n') {
            buffer[--length] = '\0';
            break;
        }
        buffer[length] = '\0';
    }
    return buffer;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And we are passing again&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "stream" (5 tests)...
Completed "ParagraphReader": 5 passes, 0 failures, 0 exceptions.
Completed "stream": 5 passes, 0 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>There are no limits to the number of stubbed methods within a test,
only that two stubs cannot have the same name. The following will
cause problems&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">static int stream_stub(void *stream) {
    return (int)mock(stream);
}

Ensure(Streams, bad_test) {
    expect(stream_stub, will_return('a'));
    do_stuff(&amp;stream_stub, &amp;stream_stub);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You <em>could</em> program the same stub to return values for the two
streams, but that would make a very brittle test. Since we&#8217;d be making
it heavily dependent on the exact internal behaviour that we are
trying to test, or test drive, it will break as soon as we change that
implementation. The test will also become very much harder to read and
understand. And we really don&#8217;t want that.</p>
</div>
<div class="paragraph">
<p>So, it will be necessary to have two stubs to make this test behave,
but that&#8217;s not a problem&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">static int first_stream_stub(void *stream) {
    return (int)mock(stream);
}

static int second_stream_stub(void *stream) {
    return (int)mock(stream);
}

Ensure(Streams, good_test) {
    expect(first_stream_stub, will_return('a'));
    expect(second_stream_stub, will_return('a'));
    do_stuff(&amp;first_stream_stub, &amp;second_stream_stub);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We now have a way of writing fast, clear tests with no external
dependencies. The information flow is still one way though, from stub
to the code under test. When our code calls complex procedures, we
won&#8217;t want to pick apart the effects to infer what happened. That&#8217;s
too much like detective work. And why should we? We just want to
know that we dispatched the correct information down the line.</p>
</div>
<div class="paragraph">
<p>Things get more interesting when we think of the traffic going the
other way, from code to stub. This gets us into the same territory as
mock objects.</p>
</div>
</div>
<div class="sect2">
<h3 id="_setting_expectations_on_mock_functions">4.3. Setting expectations on mock functions</h3>
<div class="paragraph">
<p>To swap the traffic flow, we&#8217;ll look at an outgoing example instead.
Here is the prewritten production code&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">void by_paragraph(int (*read)(void *), void *in, void (*write)(void *, char *), void *out) {
    while (1) {
        char *line = read_paragraph(read, in);
        if ((line == NULL) || (strlen(line) == 0)) {
            return;
        }
        (*write)(out, line);
        free(line);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is the start of a formatter utility.  Later filters will probably
break the paragaphs up into justified text, but right now that is all
abstracted behind the <code>void write(void *, char *)</code> interface.  Our
current interests are: does it loop through the paragraphs, and does
it crash?</p>
</div>
<div class="paragraph">
<p>We could test correct paragraph formation by writing a stub that
collects the paragraphs into a <code>struct</code>.  We could then pick apart
that <code>struct</code> and test each piece with assertions.  This approach is
extremely clumsy in C.  The language is just not suited to building
and tearing down complex edifices, never mind navigating them with
assertions.  We would badly clutter our tests.</p>
</div>
<div class="paragraph">
<p>Instead we&#8217;ll test the output as soon as possible, right in
the called function&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">...
void expect_one_letter_paragraph(void *stream, char *paragraph) {
    assert_that(paragraph, is_equal_to_string("a"));
}

Ensure(Formatter, makes_one_letter_paragraph_from_one_character_input) {
    by_paragraph(
            &amp;one_character_stream,
            NULL,
            &amp;expect_one_letter_paragraph,
            NULL);
}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>By placing the assertions into the mocked function, we keep the tests
minimal.  The catch with this method is that we are back to writing
individual functions for each test.  We have the same problem as we
had with hand coded stubs.</p>
</div>
<div class="paragraph">
<p>Again, <strong>Cgreen</strong> has a way to automate this.  Here is the rewritten
test&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">static int reader(void *stream) {
    return (int)mock(stream);
}

static void writer(void *stream, char *paragraph) {
    mock(stream, paragraph);
}

Ensure(Formatter, makes_one_letter_paragraph_from_one_character_input) {
    expect(reader, will_return('a'));
    always_expect(reader, will_return(EOF));
    expect(writer, when(paragraph, is_equal_to_string("a")));
    by_paragraph(&amp;reader, NULL, &amp;writer, NULL);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Where are the assertions?</p>
</div>
<div class="paragraph">
<p>Unlike our earlier stub, <code>reader()</code> can now check its parameters.  In
object oriented circles, an object that checks its parameters as well
as simulating behaviour is called a mock object.  By analogy
<code>reader()</code> is a mock function, or mock callback.</p>
</div>
<div class="paragraph">
<p>Using the <code>expect</code> macro, we have set up the expectation that
<code>writer()</code> will be called just once.  That call must have the string
<code>"a"</code> for the <code>paragraph</code> parameter.  If the actual value of that
parameter does not match, the mock function will issue a failure
straight to the test suite.  This is what saves us writing a lot of
assertions.</p>
</div>
<div class="paragraph">
<p>When specifying behavior of mocks there are three parts. First, how
often the specified behaviour or expectation will be executed:</p>
</div>
<table class="tableblock frame-all grid-all" style="width:100%; ">
<colgroup>
<col style="width:50%;">
<col style="width:50%;"> 
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Macro</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>expect(function, ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Expected once, in order</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>always_expect(function, ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Expect this behavior from here onwards</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>never_expect(function)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">From this point this mock function must never be called</p></td>
</tr>
</tbody>
</table>

<div class="paragraph">
<p>You can specify constraints and behaviours for each expectation
(except for <code>never_expect()</code> naturally). A constraint places
restrictions on the parameters (and will tell you if the expected
restriction was not met), and a behaviour specifies what the mock
should do if the parameter constraints are met.</p>
</div>
<div class="paragraph">
<p>A parameter constraint is defined using the <code>when(parameter,
constraint)</code> macro. It takes two parameters:</p>
</div>
<table class="tableblock frame-all grid-all" style="width:100%; ">
<colgroup>
<col style="width:50%;">
<col style="width:50%;"> 
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Parameter</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>parameter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the parameter to the mock function</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>constraint</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A constraint placed on that parameter</p></td>
</tr>
</tbody>
</table>

<div class="paragraph">
<p>There is a multitude of constraints available (actually, exactly the
same as for the assertions we saw earlier):</p>
</div>
<table class="tableblock frame-all grid-all" style="width:100%; ">
<colgroup>
<col style="width:50%;">
<col style="width:50%;"> 
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Constraint</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Type</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_greater_than(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_less_than(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Integers</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to_contents_of(pointer, size_of_contents)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bytes/Structures</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to_contents_of(pointer, size_of_contents)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Bytes/Structures</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>contains_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>does_not_contain_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>begins_with_string(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_equal_to_double(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>is_not_equal_to_double(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Double</p></td>
</tr>
</tbody>
</table>

<div class="paragraph">
<p>Then there are two ways to return results:</p>
</div>
<table class="tableblock frame-all grid-all" style="width:100%; ">
<colgroup>
<col style="width:50%;">
<col style="width:50%;"> 
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Macro</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Description</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>will_return(value)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Return the value from the mock function (which needs to be declared returning that type</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>will_set_contents_of_parameter(parameter_name, value, size)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Writes the value in the referenced parameter</p></td>
</tr>
</tbody>
</table>

<div class="paragraph">
<p>You can combine these in various ways:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">  expect(mocked_file_writer,
        when(data, is_equal_to(42)),
        will_return(EOF));
  expect(mocked_file_reader,
        when(file, is_equal_to_contents_of(&amp;FD, sizeof(FD))),
        when(input, is_equal_to_string("Hello world!"),
        will_set_contents_of_parameter(status, FD_CLOSED, sizeof(bool))));</code></pre>
</div>
</div>
<div class="paragraph">
<p>If multiple <code>when()</code> are specified they all need to be fullfilled. You
can of course only have one for each of the parameters of your mock
function.</p>
</div>
<div class="paragraph">
<p>You can also have multiple <code>will_set_contents_of_parameter()</code> in an
expectation, one for each reference parameter, but naturally only one
<code>will_return()</code>.</p>
</div>
<div class="paragraph">
<p>It&#8217;s about time we actually ran our test&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "formatter" (1 tests)...
Completed "Formatter": 1 pass, 0 failures, 0 exceptions.
Completed "formatter": 1 pass, 0 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>Confident that a single character works, we can further specify the
behaviour.  Firstly an input sequence&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">Ensure(Formatter, makes_one_paragraph_if_no_line_endings) {
    expect(reader, will_return('a'));
    expect(reader, will_return(' '));
    expect(reader, will_return('b'));
    expect(reader, will_return(' '));
    expect(reader, will_return('c'));
    always_expect(reader, will_return(EOF));
    expect(writer, when(paragraph, is_equal_to_string("a b c")));
    by_paragraph(&amp;reader, NULL, &amp;writer, NULL);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A more intelligent programmer than me would place all these calls in a
loop.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "formatter" (2 tests)...
Completed "Formatter": 2 passes, 0 failures, 0 exceptions.
Completed "formatter": 2 passes, 0 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>Next, checking an output sequence&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">Ensure(Formatter, generates_separate_paragraphs_for_line_endings) {
    expect(reader, will_return('a'));
    expect(reader, will_return('\n'));
    expect(reader, will_return('b'));
    expect(reader, will_return('\n'));
    expect(reader, will_return('c'));
    always_expect(reader, will_return(EOF));
    expect(writer, when(paragraph, is_equal_to_string("a")));
    expect(writer, when(paragraph, is_equal_to_string("b")));
    expect(writer, when(paragraph, is_equal_to_string("c")));
    by_paragraph(&amp;reader, NULL, &amp;writer, NULL);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again we can se that the <code>expect()</code> calls follow a record and playback
model.  Each one tests a successive call.  This sequence confirms that
we get <code>"a"</code>, <code>"b"</code> and <code>"c"</code> in order.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "formatter" (3 tests)...
Completed "Formatter": 5 passes, 0 failures, 0 exceptions.
Completed "formatter": 5 passes, 0 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>So, why the 5 passes? Each <code>expect()</code> with a constrait is actually
an assert. It asserts that the call specified is actually made with
the parameters given and in the specified order. In this case all the
expected calls were made.</p>
</div>
<div class="paragraph">
<p>Then we&#8217;ll make sure the correct stream pointers are passed to the
correct functions.  This is a more realistic parameter check&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">Ensure(Formatter, pairs_the_functions_with_the_resources) {
    expect(reader, when(stream, is_equal_to(1)), will_return('a'));
    always_expect(reader, when(stream, is_equal_to(1)), will_return(EOF));
    expect(writer, when(stream, is_equal_to(2)));
    by_paragraph(&amp;reader, (void *)1, &amp;writer, (void *)2);
}
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "formatter" (4 tests)...
Completed "Formatter": 9 passes, 0 failures, 0 exceptions.
Completed "formatter": 9 passes, 0 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>And finally we&#8217;ll specify that the writer is not called if
there is no paragraph.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">Ensure(Formatter, ignores_empty_paragraphs) {
    expect(reader, will_return('\n'));
    always_expect(reader, will_return(EOF));
    never_expect(writer);
    by_paragraph(&amp;reader, NULL, &amp;writer, NULL);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This last test is our undoing&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "formatter" (5 tests)...
formatter_tests.c:59: Failure: Formatter -&gt; ignores_empty_paragraphs
	Mocked function [writer] has an expectation that it will never be called, but it was

Completed "Formatter": 9 passes, 1 failure, 0 exceptions.
Completed "formatter": 9 passes, 1 failure, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>Obviously blank lines are still being dispatched to the <code>writer()</code>.
Once this is pointed out, the fix is obvious&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">void by_paragraph(int (*read)(void *), void *in, void (*write)(void *, char *), void *out) {
    while (1) {
        char *line = read_paragraph(read, in);
        if ((line == NULL) || (strlen(line) == 0)) {
            return;
        }
        (*write)(out, line);
        free(line);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tests with <code>never_expect()</code> can be very effective at uncovering subtle
bugs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "formatter" (5 tests)...
Completed "Formatter": 9 passes, 0 failures, 0 exceptions.
Completed "formatter": 9 passes, 0 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>All done.</p>
</div>
</div>
<div class="sect2">
<h3 id="_mocks_are">4.4. Mocks Are&#8230;</h3>
<div class="paragraph">
<p>Using mocks is a very handy way to isolate a unit and catch and
control calls to external units. Depending on your style of coding two
schools of thinking have emerged. And of course <strong>Cgreen</strong> supports
both!</p>
</div>
<div class="sect3">
<h4 id="_strict_or_loose_mocks">4.4.1. Strict or Loose Mocks</h4>
<div class="paragraph">
<p>The two schools are thinking a bit differently about what mock
expectations means. Does it mean that all external calls must be
declared and expected? What happens if a call was made to a mock that
wasn&#8217;t expected? And vice versa, if an expected call was not made?</p>
</div>
<div class="paragraph">
<p>Actually, the thinking is not only a school of thought, but you might
want to switch from one to the other. So <strong>Cgreen</strong> allows for that too.</p>
</div>
<div class="paragraph">
<p>By default <strong>Cgreen</strong> mocks are <em>strict</em>, which means that a call to
an non-expected mock will be considered a failure. So will an expected
call that was not fullfilled. You might consider this a way to define
a unit through all its exact behaviours towards its neighbours.</p>
</div>
<div class="paragraph">
<p>On the other hand, <em>loose</em> mocks are looser. They allow both
unfullfilled expectations and try to handle unexpected calls in a
reasonable way.</p>
</div>
<div class="paragraph">
<p>You can use both with in the same suite of tests using the call
<code>cgreen_mocks_are(strict_mocks);</code> and <code>cgreen_mocks_are(loose_mocks);</code>
respectively.</p>
</div>
</div>
<div class="sect3">
<h4 id="_learning_mocks">4.4.2. Learning Mocks</h4>
<div class="paragraph">
<p>Working with legacy code and trying to apply TDD, BDD or even simply
add some unit tests is not easy. You&#8217;re working with unknown code that
does unknown things with unknown counterparts.</p>
</div>
<div class="paragraph">
<p>So the first step would be to isolate the unit. We won&#8217;t go into
details on how to do that here, but basically you would replace the
interface to other units with mocks. This is a somewhat tedious manual
labor, but will result in an isolated unit where you can start
applying your unit tests.</p>
</div>
<div class="paragraph">
<p>Once you have your unit isolated in a harness of mocks, we need to
figure out which calls it does to other units, now replaced by mocks,
in the specific case we are trying to test.</p>
</div>
<div class="paragraph">
<p>This might be complicated, so <strong>Cgreen</strong> makes that a bit simpler. There
is a third <em>mode</em> of the <strong>Cgreen</strong> mocks, the learning mocks.</p>
</div>
<div class="paragraph">
<p>If you temporarily add the call <code>cgreen_mocks_are(learning_mocks);</code> at
the beginning of your unit test, the mocks will record all calls and
present a list of those calls in order, including the actual parameter
values, on the standard output.</p>
</div>
<div class="paragraph">
<p>So let&#8217;s look at the following example from the <strong>Cgreen</strong> unit
tests. It&#8217;s a bit contorted since the test actually call the mocked
functions directly, but I believe it will serve as an example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">static int integer_out() {
    return (int)mock();
}

static char *string_out(int p1) {
    return (char *)mock(p1);
}

Ensure(LearningMocks, emit_pastable_code) {
    cgreen_mocks_are(learning_mocks);
    string_out(1);
    string_out(2);
    integer_out();
    integer_out();
    string_out(3);
    integer_out();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can see the call to <code>cgreen_mocks_are()</code> starting the test and
setting the mocks into learning mode.</p>
</div>
<div class="paragraph">
<p>If we run this, just as we usually run tests, the following will show
up in our terminal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "learning_mocks" (1 tests)...
LearningMocks -&gt; emit_pastable_code : Learned mocks are
        expect(string_out, when(p1, is_equal_to(1)));
        expect(string_out, when(p1, is_equal_to(2)));
        expect(integer_out);
        expect(integer_out);
        expect(string_out, when(p1, is_equal_to(3)));
        expect(integer_out);
Completed "LearningMocks": 0 passes, 0 failures, 0 exceptions.
Completed "learning_mocks": 0 passes, 0 failures, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>If this was for real we could just copy this and paste it in place of
the call to <code>cgreen_mocks_are()</code> and we have all the expectations
done.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_context_subject_under_test_suites">5. Context, Subject Under Test &amp; Suites</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As mentioned earlier, <strong>Cgreen</strong> promotes the behaviour driven
style of test driving code. The thinking behind BDD is that we don&#8217;t
really want to test anything, if we just could specify the behaviour
of our code and ensure that it actually behaves this way we would be
fine.</p>
</div>
<div class="paragraph">
<p>This might seem like an age old dream, but when you think about it,
there is actually very little difference in the mechanics from
vanillla TDD. First we write how we want it, then implement it. But
the small change in wording, from `test¬¥ to `behaviour¬¥, from `test
that¬¥ to `ensure that¬¥, makes a huge difference in thinking, and also
very often in quality of the resulting code.</p>
</div>
<div class="sect2">
<h3 id="_the_sut_subject_under_test">5.1. The SUT - Subject Under Test</h3>
<div class="paragraph">
<p>Since BDD talks about behaviour, there has to be something that we can
talk about as having the wanted behaviour. This is usually called the
SUT, the Subject Under Test. <strong>Cgreen</strong> in BDD-ish mode requires that you
define a name for it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;cgreen/cgreen.h&gt;
Describe(SUT);</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Cgreen</strong> supports C++ and there you naturally have the objects and
also the Class Under Test. But in plain C you will have to think about
what is actually the "class" under test. E.g. in <code>sort_test.c</code> you might
see</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;cgreen/cgreen.h&gt;
Describe(Sorter);

Ensure(Sorter, can_sort_an_empty_list) {
  assert_that(sorter(NULL), is_null);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example you can clearly see what difference the BDD-ish style
makes when it comes to naming. Convention, and natural language,
dictates that typical names for what TDD would call tests, now starts
with <em>can</em> or <em>finds</em> or other verbs, which makes the specification so
much easier to read.</p>
</div>
<div class="paragraph">
<p>Yes, I wrote <em>specification</em>. Because that is how BDD views what TDD
basically calls a test suite. The suite specifies the behaviour of a
`class¬¥. (That&#8217;s why some BDD frameworks draw on <em>spec</em>, like
<strong>RSpec</strong>.)</p>
</div>
</div>
<div class="sect2">
<h3 id="_contexts_and_before_and_after">5.2. Contexts and Before and After</h3>
<div class="paragraph">
<p>The complete specification of the behaviour of a SUT might become long
and require various forms of setup. When using TDD style you
would probably break this up into multiple suites having their own
<code>setup()</code> and <code>teardown()</code>.</p>
</div>
<div class="paragraph">
<p>With BDD-ish style we could consider a suite as a behaviour
specification for our SUT <em>in a particular context</em>. E.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;cgreen/cgreen.h&gt;

Describe(shopping_basket_for_returning_customer);

Customer *customer;

BeforeEach(shopping_basket_for_returning_customer){
  customer = create_test_customer();
  login(customer);
}

AfterEach(shopping_basket_for_returning_customer) {
  logout(customer);
  destroy_customer(customer);
}

Ensure(shopping_basket_for_returning_customer, can_use_discounts) {
  ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <em>context</em> would then be <code>shopping_basket_for_returning_customer</code>,
with the SUT being the shopping basket <em>class</em>.</p>
</div>
<div class="paragraph">
<p>So <em>context</em>, <em>subject under test</em> and <em>suite</em> are mostly
interchangable concepts in <strong>Cgreen</strong> lingo. It&#8217;s a named group of
<em>tests</em> that share the same <code>BeforeEach</code> and <code>AfterEach</code> and lives in
the same source file.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_changing_style">6. Changing Style</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you already have some TDD style <strong>Cgreen</strong> test suites, it is quite
easy to change them over to BDD-ish style. Here are the steps required</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Add <code>Describe(SUT);</code></p>
</li>
<li>
<p>Turn your current setup function into a <code>BeforeEach()</code> definition by
changing its signature to match the macro, or simply call the existing
setup function from the BeforeEach(). If you don&#8217;t have any setup function
you still need to define an empty <code>BeforeEach()</code>.</p>
</li>
<li>
<p>Ditto for <code>AfterEach()</code>.</p>
</li>
<li>
<p>Add the SUT to each <code>Ensure()</code> by inserting it as a first parameter.</p>
</li>
<li>
<p>Change the call to add the tests to <code>add_test_with_context()</code> by
adding the name of the SUT as the second parameter.</p>
</li>
<li>
<p>Optionally remove the calls to <code>set_setup()</code> and <code>set_teardown()</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Done.</p>
</div>
<div class="paragraph">
<p>If you want to continue to run the tests using a hand-coded runner,
you can do that by keeping the setup and teardown functions and their
corresponding <code>set_</code>-calls.</p>
</div>
<div class="paragraph">
<p>It&#8217;s nice that this is a simple process, because you can change over
from TDD style to BDD-ish style in small steps. You can convert one source
file at a time, by just following the recipe above. Everything will
still work as before but your tests and code will likely improve.</p>
</div>
<div class="paragraph">
<p>And once you have changed style you can fully benefit from the
automatic discovery of tests as described in <a href="#runner">Automatic Test
Discovery</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_changing_cgreen_reporting">7. Changing Cgreen Reporting</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_replacing_the_reporter">7.1. Replacing the reporter</h3>
<div class="paragraph">
<p>In every test suite so far, we have run the tests with this line&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">return run_test_suite(our_tests(), create_text_reporter());</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can change the reporting mechanism just by changing this
method.</p>
</div>
<div class="paragraph">
<p>Here is the code for <code>create_text_reporter()</code>&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">TestReporter *create_text_reporter(void) {
    TestReporter *reporter = create_reporter();
    if (reporter == NULL) {
        return NULL;
    }
    reporter-&gt;start_suite = &amp;text_reporter_start_suite;
    reporter-&gt;start_test = &amp;text_reporter_start_test;
    reporter-&gt;show_fail = &amp;show_fail;
    reporter-&gt;show_incomplete = &amp;show_incomplete;
    reporter-&gt;finish_test = &amp;text_reporter_finish;
    reporter-&gt;finish_suite = &amp;text_reporter_finish;
    return reporter;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>TestReporter</code> structure contains function pointers that control
the reporting.  When called from <code>create_reporter()</code> constructor,
these pointers are set up with functions that display nothing. The
text reporter code replaces these with something more dramatic, and
then returns a pointer to this new object. Thus the
<code>create_text_reporter()</code> function effectively extends the object from
<code>create_reporter()</code>.</p>
</div>
<div class="paragraph">
<p>The text reporter only outputs content at the start of the first test,
at the end of the test run to display the results, when a failure
occurs, and when a test fails to complete.  A quick look at the
<code>text_reporter.c</code> file in <strong>Cgreen</strong> reveals that the overrides just
output a message and chain to the versions in <code>reporter.h</code>.</p>
</div>
<div class="paragraph">
<p>To change the reporting mechanism ourselves, we just have to know a little
about the methods in the <code>TestReporter</code> structure.</p>
</div>
</div>
<div class="sect2">
<h3 id="_the_testreporter_structure">7.2. The TestReporter structure</h3>
<div class="paragraph">
<p>The <strong>Cgreen</strong> <code>TestReporter</code> is a pseudo class that looks
something like&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">typedef struct _TestReporter TestReporter;
struct _TestReporter {
    void (*destroy)(TestReporter *reporter);
    void (*start_suite)(TestReporter *reporter, const char *name, const int count);
    void (*start_test)(TestReporter *reporter, const char *name);
    void (*show_pass)(TestReporter *reporter, const char *file, int line,
                                   const char *message, va_list arguments);
    void (*show_fail)(TestReporter *reporter, const char *file, int line,
                                   const char *message, va_list arguments);
    void (*show_incomplete)(TestReporter *reporter, const char *file, int line,
                                   const char *message, va_list arguments);
    void (*assert_true)(TestReporter *reporter, const char *file, int line, int result,
                                   const char * message, ...);
    void (*finish_test)(TestReporter *reporter, const char *file, int line);
    void (*finish_suite)(TestReporter *reporter, const char *file, int line);
    int passes;
    int failures;
    int exceptions;
    void *breadcrumb;
    int ipc;
    void *memo;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first block are the methods that can be overridden.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">void (*destroy)(TestReporter *reporter)</dt>
<dd>
<p>This is the destructor for the default
structure. If this is overridden, then the overriding function must call
<code>destroy_reporter(TestReporter *reporter)</code> to finish the clean up.</p>
</dd>
<dt class="hdlist1">void (*start_suite)(TestReporter *reporter, const char *name, const int count)</dt>
<dd>
<p>This is the first of the callbacks. At the start of
each test suite <strong>Cgreen</strong> will call this method on the reporter with
the name of the suite being entered and the number of tests in that
suite. The default version keeps track of the stack of tests in the
<code>breadcrumb</code> pointer of <code>TestReporter</code>. If you make use of the
breadcrumb functions, as the defaults do, then you will need to call
<code>reporter_start()</code> to keep the book keeping in sync.</p>
</dd>
<dt class="hdlist1">void (*start_test)(TestReporter *reporter, const char *name)</dt>
<dd>
<p>At the start of each test <strong>Cgreen</strong> will call this method on the
reporter with the name of the test being entered. Again, the default
version keeps track of the stack of tests in the <code>breadcrumb</code> pointer
of <code>TestReporter</code>. If you make use of the breadcrumb functions, as the
defaults do, then you will need to call <code>reporter_start()</code> to keep the
book keeping in sync.</p>
</dd>
<dt class="hdlist1">void (*show_pass)(TestReporter *reporter, const char *file, int line, const char *message, va_list arguments)</dt>
<dd>
<p>This method is initially empty as there most reporters see little
point in reporting passing tests (but you might do), so there is no
need to chain the call to any other function. Besides the pointer to
the reporter structure, <strong>Cgreen</strong> also passes the file name of the
test, the line number of failed assertion, the message to show and any
additional parameters to substitute into the message. The message
comes in as <code>printf()</code> style format string, and so the variable
argument list should match the substitutions.</p>
</dd>
<dt class="hdlist1">void (*show_fail)(TestReporter *reporter, const char *file, int line, const char *message, va_list arguments)</dt>
<dd>
<p>The partner of <code>show_pass()</code>, and the one you&#8217;ll likely overload first.</p>
</dd>
<dt class="hdlist1">void (*show_incomplete)(TestReporter *reporter, const char *file, int line, const char *message, va_list arguments)</dt>
<dd>
<p>When a test fails to complete, this is the handler that is called. As it&#8217;s an unexpected
outcome, no message is received, but we do get the name of the
test. The text reporter combines this with the breadcrumb to produce
the exception report.</p>
</dd>
<dt class="hdlist1">void (*assert_true)(TestReporter *reporter, const char *file, int line, int result, const char * message, &#8230;)</dt>
<dd>
<p>This is not normally
overridden and is really internal. It is the raw entry point for the
test messages from the test suite. By default it dispatches the call
to either <code>show_pass()</code> or <code>show_fail()</code>.</p>
</dd>
<dt class="hdlist1">void (*finish_test)(TestReporter *reporter, const char *file, int line)</dt>
<dd>
<p>The counterpart to the <code>(*start_test)()</code> call. It is called
on leaving the test. It needs to be chained to the
<code>reporter_finish()</code> to keep track of the breadcrumb book keeping.</p>
</dd>
<dt class="hdlist1">void (*finish_suite)(TestReporter *reporter, const char *file, int line)</dt>
<dd>
<p>The counterpart to the <code>(*start_suite)()</code> call called on
leaving the test suite, and similar to the <code>(*finish_test)()</code> if your
reporter needs a handle on that event too. The default text reporter
chains both this and <code>(*finish_test)()</code> to the same function where it
figures out if it is the end of the top level suite. If so, it prints
the familiar summary of passes and fails.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>The second block is simply resources and book keeping that the reporter
can use to liven up the messages&#8230;</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
passes
</td>
<td class="hdlist2">
<p>The number of passes so far.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
failures
</td>
<td class="hdlist2">
<p>The number of failures generated so far.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
exceptions
</td>
<td class="hdlist2">
<p>The number of test functions that have failed to complete so far.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
breadcrumb
</td>
<td class="hdlist2">
<p>This is a pointer to the list of test names in the stack.</p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>breadcrumb</code> pointer is different and needs a little explanation.
Basically it is a stack, analogous to the breadcrumb trail you see on
websites.  Everytime a <code>start()</code> handler is invoked, the name is
placed in this stack.  When a <code>finish()</code> message handler is invoked, a
name is popped off.</p>
</div>
<div class="paragraph">
<p>There are a bunch of utility functions in <code>cgreen/breadcrumb.h</code> that
can read the state of this stack.  Most useful are
<code>get_current_from_breadcrumb()</code> which takes the breadcrumb pointer and
returns the current test name, and <code>get_breadcrumb_depth()</code> which gives
the current depth of the stack.  A depth of zero means that the test
run has finished.</p>
</div>
<div class="paragraph">
<p>If you need to traverse all the names in the breadcrumb, then you can
call <code>walk_breadcrumb()</code>.  Here is the full signature&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">void walk_breadcrumb(Breadcrumb *breadcrumb, void (*walker)(const char *, void *), void *memo);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>void (*walker)(const char *, void *)</code> is a callback that will be
passed the name of the test suite for each level of nesting.</p>
</div>
<div class="paragraph">
<p>It is also passed the <code>memo</code> pointer that was passed to the
<code>walk_breadcrumb()</code> call.  You can use this pointer for anything you
want, as all <strong>Cgreen</strong> does is pass it from call to call.  This is so
aggregate information can be kept track of whilst still being
reentrant.</p>
</div>
<div class="paragraph">
<p>The last parts of the <code>TestReporter</code> structure are&#8230;</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
ipc
</td>
<td class="hdlist2">
<p>This is an internal structure for handling the messaging between reporter
and test suite. You shouldn&#8217;t touch this.</p>
</td>
</tr>
<tr>
<td class="hdlist1">
memo
</td>
<td class="hdlist2">
<p>By contrast, this is a spare pointer for your own expansion.</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_an_example_xml_reporter">7.3. An example XML reporter</h3>
<div class="paragraph">
<p>Let&#8217;s make things real with an example.  Suppose we want to send the
output from <strong>Cgreen</strong> in XML format, say for storing in a repository or
for sending across the network.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
The <code>cgreen-runner</code> already has an XML-reporter that you can
use. See <a href="#options">Cgreen Runner Options</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Suppose also that we have come up with the following format&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="xml language-xml">&lt;?xml?&gt;
&lt;suite name="Top Level"&gt;
    &lt;suite name="A Group"&gt;
        &lt;test name="a_test_that_passes"&gt;
        &lt;/test&gt;
        &lt;test name="a_test_that_fails"&gt;
            &lt;fail&gt;
                &lt;message&gt;A failure&lt;/message&gt;
                &lt;location file="test_as_xml.c" line="8"/&gt;
            &lt;/fail&gt;
        &lt;/test&gt;
    &lt;/suite&gt;
&lt;/suite&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In other words a simple nesting of tests with only failures encoded.
The absence of "fail" XML node is a pass.</p>
</div>
<div class="paragraph">
<p>Here is a test script, <code>test_as_xml.c</code> that we can use to construct the
above output&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;cgreen/cgreen.h&gt;

Describe(XML_reporter);
BeforeEach(XML_reporter) {}
AfterEach(XML_reporter) {}

Ensure(XML_reporter, reports_a_test_that_passes) {
    assert_that(1 == 1);
}

Ensure(XML_reporter, reports_a_test_that_fails) {
    fail_test("A failure");
}

TestSuite *create_test_group() {
    TestSuite *suite = create_named_test_suite("A Group");
    add_test_with_context(suite, XML_reporter, reports_a_test_that_passes);
    add_test_with_context(suite, XML_reporter, reports_a_test_that_fails);
    return suite;
}

int main(int argc, char **argv) {
    TestSuite *suite = create_named_test_suite("Top Level");
    add_suite(suite, create_test_group());
    return run_test_suite(suite, create_text_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can&#8217;t use the auto-discovering <code>cgreen-runner</code> here since we need
to ensure that the nested suites are reported as a nested xml
structure. And we&#8217;re not actually writing real tests, just something
that we can use to drive our new reporter.</p>
</div>
<div class="paragraph">
<p>The text reporter is used just to confirm that everything is
working. So far it is.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Running "Top Level" (2 tests)...
test_as_xml.c:12: Failure: A Group -&gt; reports_a_test_that_fails
	A failure

Completed "A Group": 1 pass, 1 failure, 0 exceptions.
Completed "Top Level": 1 pass, 1 failure, 0 exceptions.</pre>
</div>
</div>
<div class="paragraph">
<p>Our first move is to switch the reporter from text, to our
not yet written XML version&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include "xml_reporter.h"
...

int main(int argc, char **argv) {
    TestSuite *suite = create_named_test_suite("Top Level");
    add_suite(suite, create_test_group());
    return run_test_suite(suite, create_xml_reporter());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We&#8217;ll start the ball rolling with the <code>xml_reporter.h</code>
header file&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#ifndef _XML_REPORTER_HEADER_
#define _XML_REPORTER_HEADER_

#include &lt;cgreen/reporter.h&gt;

TestReporter *create_xml_reporter();

#endif</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;and the simplest possible reporter in <code>xml_reporter.c</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;cgreen/reporter.h&gt;

#include "xml_reporter.h"

TestReporter *create_xml_reporter() {
    TestReporter *reporter = create_reporter();
    return reporter;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>One that outputs nothing.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gcc -c test_as_xml.c
$ gcc -c xml_reporter.c
$ gcc xml_reporter.o test_as_xml.o -lcgreen -o xml
$ ./xml</pre>
</div>
</div>
<div class="paragraph">
<p>Yep, nothing.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s add the outer XML tags first, so that we can see <strong>Cgreen</strong>
navigating the test suite&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;cgreen/reporter.h&gt;
#include &lt;cgreen/breadcrumb.h&gt;

#include &lt;stdio.h&gt;
#include "xml_reporter.h"


static void xml_reporter_start_suite(TestReporter *reporter, const char *name, int count) {
    printf("&lt;suite name=\"%s\"&gt;\n", name);
    reporter_start(reporter, name);
}

static void xml_reporter_start_test(TestReporter *reporter, const char *name) {
    printf("&lt;test name=\"%s\"&gt;\n", name);
    reporter_start(reporter, name);
}

static void xml_reporter_finish_test(TestReporter *reporter, const char *filename, int line, const char *message) {
    reporter_finish(reporter, filename, line, message);
    printf("&lt;/test&gt;\n");
}

static void xml_reporter_finish_suite(TestReporter *reporter, const char *filename, int line) {
    reporter_finish(reporter, filename, line, "");
    printf("&lt;/suite&gt;\n");
}

TestReporter *create_xml_reporter() {
    TestReporter *reporter = create_reporter();
    reporter-&gt;start_suite = &amp;xml_reporter_start_suite;
    reporter-&gt;start_test = &amp;xml_reporter_start_test;
    reporter-&gt;finish_test = &amp;xml_reporter_finish_test;
    reporter-&gt;finish_suite = &amp;xml_reporter_finish_suite;
    return reporter;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Although chaining to the underlying <code>reporter_start()</code>
and <code>reporter_finish()</code> functions is optional, I want to
make use of some of the facilities later.</p>
</div>
<div class="paragraph">
<p>Our output meanwhile, is making its first tentative steps&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="xml language-xml">&lt;suite name="Top Level"&gt;
&lt;suite name="A Group"&gt;
&lt;test name="reports_a_test_that_passes"&gt;
&lt;/test&gt;
&lt;test name="reports_a_test_that_fails"&gt;
&lt;/test&gt;
&lt;/suite&gt;
&lt;/suite&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>We don&#8217;t require an XML node for passing tests, so the <code>show_fail()</code>
function is all we need&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">...

static void xml_show_fail(TestReporter *reporter, const char *file, int line, const char *message, va_list arguments) {
    printf("&lt;fail&gt;\n");
    printf("\t&lt;message&gt;");
    vprintf(message, arguments);
    printf("&lt;/message&gt;\n");
    printf("\t&lt;location file=\"%s\" line=\"%d\"/&gt;\n", file, line);
    printf("&lt;/fail&gt;\n");
...

TestReporter *create_xml_reporter() {
    TestReporter *reporter = create_reporter();
    reporter-&gt;start_suite = &amp;xml_reporter_start_suite;
    reporter-&gt;start_test = &amp;xml_reporter_start_test;
    reporter-&gt;show_fail = &amp;xml_show_fail;
    reporter-&gt;finish_test = &amp;xml_reporter_finish_test;
    reporter-&gt;finish_suite = &amp;xml_reporter_finish_suite;
    return reporter;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We have to use <code>vprintf()</code> to handle the variable argument list passed
to us.  This will probably mean including the <code>stdarg.h</code> header as
well as <code>stdio.h</code>.</p>
</div>
<div class="paragraph">
<p>This gets us pretty close to what we want&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="xml language-xml">&lt;suite name="Top Level"&gt;
&lt;suite name="A Group"&gt;
&lt;test name="reports_a_test_that_passes"&gt;
&lt;/test&gt;
&lt;test name="reports_a_test_that_fails"&gt;
&lt;fail&gt;
        &lt;message&gt;A failure&lt;/message&gt;
        &lt;location file="test_as_xml.c" line="15"/&gt;
&lt;/fail&gt;
&lt;/test&gt;
&lt;/suite&gt;
&lt;/suite&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For completeness we should add a tag for a test that doesn&#8217;t complete.
We&#8217;ll output this as a failure, although we don&#8217;t bother with the
location this time&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">static void xml_show_incomplete(TestReporter *reporter, const char *file, int line, const char *message, va_list arguments) {
    printf("&lt;fail&gt;\n");
    printf("\t&lt;message&gt;Failed to complete&lt;/message&gt;\n");
    printf("&lt;/fail&gt;\n");
}
...
TestReporter *create_xml_reporter() {
    TestReporter *reporter = create_reporter();
    reporter-&gt;start_suite = &amp;xml_reporter_start_suite;
    reporter-&gt;start_test = &amp;xml_reporter_start_test;
    reporter-&gt;show_fail = &amp;xml_show_fail;
    reporter-&gt;show_incomplete = &amp;xml_show_incomplete;
    reporter-&gt;finish_test = &amp;xml_reporter_finish_test;
    reporter-&gt;finish_suite = &amp;xml_reporter_finish_suite;
    return reporter;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>All that&#8217;s left then is the XML declaration and the thorny issue of
indenting.  Although the indenting is not strictly necessary, it would
make the output a lot more readable.</p>
</div>
<div class="paragraph">
<p>Given that the test depth is kept track of for us with the
<code>breadcrumb</code> object in the <code>TestReporter</code> structure, indentation will
actually be quite simple.  We&#8217;ll add an <code>indent()</code> function that
outputs the correct number of tabs&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">static void indent(TestReporter *reporter) {
    int depth = get_breadcrumb_depth((CgreenBreadcrumb *)reporter-&gt;breadcrumb);
    while (depth-- &gt; 0) {
        printf("\t");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>get_breadcrumb_depth()</code> function just gives the current test
depth as recorded in the reporters breadcrumb (from
<code>cgreen/breadcrumb.h</code>).  As that is just the number of tabs to output,
the implementation is trivial.</p>
</div>
<div class="paragraph">
<p>We can then use this function in the rest of the code.  Here is the
complete listing&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="c language-c">#include &lt;cgreen/reporter.h&gt;
#include &lt;cgreen/breadcrumb.h&gt;

#include &lt;stdio.h&gt;
#include "xml_reporter.h"

static void indent(TestReporter *reporter) {
    int depth = get_breadcrumb_depth((CgreenBreadcrumb *)reporter-&gt;breadcrumb);
    while (depth-- &gt; 0) {
        printf("\t");
    }
}

static void xml_reporter_start_suite(TestReporter *reporter, const char *name, int count) {
    if (get_breadcrumb_depth((CgreenBreadcrumb *)reporter-&gt;breadcrumb) == 0) {
        printf("&lt;?xml?&gt;\n");
    }
    indent(reporter);
    printf("&lt;suite name=\"%s\"&gt;\n", name);
    reporter_start(reporter, name);
}

static void xml_reporter_start_test(TestReporter *reporter, const char *name) {
    indent(reporter);
    printf("&lt;test name=\"%s\"&gt;\n", name);
    reporter_start(reporter, name);
}

static void xml_show_fail(TestReporter *reporter, const char *file, int line, const char *message, va_list arguments) {
    indent(reporter);
    printf("&lt;fail&gt;\n");
    indent(reporter);
    printf("\t&lt;message&gt;");
    vprintf(message, arguments);
    printf("&lt;/message&gt;\n");
    indent(reporter);
    printf("\t&lt;location file=\"%s\" line=\"%d\"/&gt;\n", file, line);
    indent(reporter);
    printf("&lt;/fail&gt;\n");
}

static void xml_show_incomplete(TestReporter *reporter, const char *file, int line, const char *message, va_list arguments) {
    indent(reporter);
    printf("&lt;fail&gt;\n");
    indent(reporter);
    printf("\t&lt;message&gt;Failed to complete&lt;/message&gt;\n");
    indent(reporter);
    printf("&lt;/fail&gt;\n");
}


static void xml_reporter_finish_test(TestReporter *reporter, const char *filename, int line, const char *message) {
    reporter_finish(reporter, filename, line, message);
    indent(reporter);
    printf("&lt;/test&gt;\n");
}

static void xml_reporter_finish_suite(TestReporter *reporter, const char *filename, int line) {
    reporter_finish(reporter, filename, line, "");
    indent(reporter);
    printf("&lt;/suite&gt;\n");
}

TestReporter *create_xml_reporter() {
    TestReporter *reporter = create_reporter();
    reporter-&gt;start_suite = &amp;xml_reporter_start_suite;
    reporter-&gt;start_test = &amp;xml_reporter_start_test;
    reporter-&gt;show_fail = &amp;xml_show_fail;
    reporter-&gt;show_incomplete = &amp;xml_show_incomplete;
    reporter-&gt;finish_test = &amp;xml_reporter_finish_test;
    reporter-&gt;finish_suite = &amp;xml_reporter_finish_suite;
    return reporter;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And finally the desired output&#8230;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="xml language-xml">&lt;?xml?&gt;
&lt;suite name="Top Level"&gt;
	&lt;suite name="A Group"&gt;
		&lt;test name="reports_a_test_that_passes"&gt;
		&lt;/test&gt;
		&lt;test name="reports_a_test_that_fails"&gt;
			&lt;fail&gt;
				&lt;message&gt;A failure&lt;/message&gt;
				&lt;location file="test_as_xml.c" line="15"/&gt;
			&lt;/fail&gt;
		&lt;/test&gt;
	&lt;/suite&gt;
&lt;/suite&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Job done.</p>
</div>
<div class="paragraph">
<p>Possible other reporter customizations include reporters that write to
<code>syslog</code>, talk to IDE plug-ins, paint pretty printed documents or just
return a boolean for monitoring purposes.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hints_and_tips">8. Hints and Tips</h2>
<div class="sectionbody">
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="icon-caution" title="Caution"></i>
</td>
<td class="content">
This chapter is in its infancy. It will contain tips for
situations that you need some help to get out of, typically strange
error messages from the compiler. Since <strong>Cgreen</strong> uses some C/C++ macro
magic this can happen and the error messages might not be straight
forward to interpret.
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all" style="width:100%; ">
<colgroup>
<col style="width:50%;">
<col style="width:50%;"> 
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Compiler error message</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Probable cause&#8230;</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"contextFor&lt;X&gt;" is undeclared here</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">You forgot the <code>BeforeEach()</code> function</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>undefined reference to 'AfterEach_For_&lt;X&gt;'</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">You forgot the <code>AfterEach()</code> function</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CgreenSpec__&lt;X&gt;__&lt;Y&gt;__ is undeclared</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">You forgot to specify the test subject/context in a BDD style test</p></td>
</tr>
</tbody>
</table>

</div>
</div>
<div class="sect1">
<h2 id="_gnu_free_documentation_license">9. Appendix A: GNU Free Documentation License</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre>
    Version 1.1, March 2000


      Copyright (C) 2000  Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.

    0. PREAMBLE

    The purpose of this License is to make a manual, textbook,
    or other written document "free" in the sense of freedom: to
    assure everyone the effective freedom to copy and redistribute it,
    with or without modifying it, either commercially or
    noncommercially.  Secondarily, this License preserves for the
    author and publisher a way to get credit for their work, while not
    being considered responsible for modifications made by
    others.

    This License is a kind of "copyleft", which means that
    derivative works of the document must themselves be free in the
    same sense.  It complements the GNU General Public License, which
    is a copyleft license designed for free software.

    We have designed this License in order to use it for manuals
    for free software, because free software needs free documentation:
    a free program should come with manuals providing the same
    freedoms that the software does.  But this License is not limited
    to software manuals; it can be used for any textual work,
    regardless of subject matter or whether it is published as a
    printed book.  We recommend this License principally for works
    whose purpose is instruction or reference.

    1. APPLICABILITY AND DEFINITIONS

    This License applies to any manual or other work that
    contains a notice placed by the copyright holder saying it can be
    distributed under the terms of this License.  The "Document",
    below, refers to any such manual or work.  Any member of the
    public is a licensee, and is addressed as "you".

    A "Modified Version" of the Document means any work
    containing the Document or a portion of it, either copied
    verbatim, or with modifications and/or translated into another
    language.

    A "Secondary Section" is a named appendix or a front-matter
    section of the Document that deals exclusively with the
    relationship of the publishers or authors of the Document to the
    Document's overall subject (or to related matters) and contains
    nothing that could fall directly within that overall subject.
    (For example, if the Document is in part a textbook of
    mathematics, a Secondary Section may not explain any mathematics.)
    The relationship could be a matter of historical connection with
    the subject or with related matters, or of legal, commercial,
    philosophical, ethical or political position regarding
    them.

    The "Invariant Sections" are certain Secondary Sections
    whose titles are designated, as being those of Invariant Sections,
    in the notice that says that the Document is released under this
    License.

    The "Cover Texts" are certain short passages of text that
    are listed, as Front-Cover Texts or Back-Cover Texts, in the
    notice that says that the Document is released under this
    License.

    A "Transparent" copy of the Document means a
    machine-readable copy, represented in a format whose specification
    is available to the general public, whose contents can be viewed
    and edited directly and straightforwardly with generic text
    editors or (for images composed of pixels) generic paint programs
    or (for drawings) some widely available drawing editor, and that
    is suitable for input to text formatters or for automatic
    translation to a variety of formats suitable for input to text
    formatters.  A copy made in an otherwise Transparent file format
    whose markup has been designed to thwart or discourage subsequent
    modification by readers is not Transparent.  A copy that is not
    "Transparent" is called "Opaque".

    Examples of suitable formats for Transparent copies include
    plain ASCII without markup, Texinfo input format, LaTeX input
    format, SGML or XML using a publicly available DTD, and
    standard-conforming simple HTML designed for human modification.
    Opaque formats include PostScript, PDF, proprietary formats that
    can be read and edited only by proprietary word processors, SGML
    or XML for which the DTD and/or processing tools are not generally
    available, and the machine-generated HTML produced by some word
    processors for output purposes only.

    The "Title Page" means, for a printed book, the title page
    itself, plus such following pages as are needed to hold, legibly,
    the material this License requires to appear in the title page.
    For works in formats which do not have any title page as such,
    "Title Page" means the text near the most prominent appearance of
    the work's title, preceding the beginning of the body of the
    text.

    2. VERBATIM COPYING

    You may copy and distribute the Document in any medium,
    either commercially or noncommercially, provided that this
    License, the copyright notices, and the license notice saying this
    License applies to the Document are reproduced in all copies, and
    that you add no other conditions whatsoever to those of this
    License.  You may not use technical measures to obstruct or
    control the reading or further copying of the copies you make or
    distribute.  However, you may accept compensation in exchange for
    copies.  If you distribute a large enough number of copies you
    must also follow the conditions in section 3.

    You may also lend copies, under the same conditions stated
    above, and you may publicly display copies.

    3. COPYING IN QUANTITY

    If you publish printed copies of the Document numbering more
    than 100, and the Document's license notice requires Cover Texts,
    you must enclose the copies in covers that carry, clearly and
    legibly, all these Cover Texts: Front-Cover Texts on the front
    cover, and Back-Cover Texts on the back cover.  Both covers must
    also clearly and legibly identify you as the publisher of these
    copies.  The front cover must present the full title with all
    words of the title equally prominent and visible.  You may add
    other material on the covers in addition.  Copying with changes
    limited to the covers, as long as they preserve the title of the
    Document and satisfy these conditions, can be treated as verbatim
    copying in other respects.

    If the required texts for either cover are too voluminous to
    fit legibly, you should put the first ones listed (as many as fit
    reasonably) on the actual cover, and continue the rest onto
    adjacent pages.

    If you publish or distribute Opaque copies of the Document
    numbering more than 100, you must either include a
    machine-readable Transparent copy along with each Opaque copy, or
    state in or with each Opaque copy a publicly-accessible
    computer-network location containing a complete Transparent copy
    of the Document, free of added material, which the general
    network-using public has access to download anonymously at no
    charge using public-standard network protocols.  If you use the
    latter option, you must take reasonably prudent steps, when you
    begin distribution of Opaque copies in quantity, to ensure that
    this Transparent copy will remain thus accessible at the stated
    location until at least one year after the last time you
    distribute an Opaque copy (directly or through your agents or
    retailers) of that edition to the public.

    It is requested, but not required, that you contact the
    authors of the Document well before redistributing any large
    number of copies, to give them a chance to provide you with an
    updated version of the Document.

    4. MODIFICATIONS

    You may copy and distribute a Modified Version of the
    Document under the conditions of sections 2 and 3 above, provided
    that you release the Modified Version under precisely this
    License, with the Modified Version filling the role of the
    Document, thus licensing distribution and modification of the
    Modified Version to whoever possesses a copy of it.  In addition,
    you must do these things in the Modified Version:

      Use in the Title Page
      (and on the covers, if any) a title distinct from that of the
      Document, and from those of previous versions (which should, if
      there were any, be listed in the History section of the
      Document).  You may use the same title as a previous version if
      the original publisher of that version gives permission.


      List on the Title Page,
      as authors, one or more persons or entities responsible for
      authorship of the modifications in the Modified Version,
      together with at least five of the principal authors of the
      Document (all of its principal authors, if it has less than
      five).


      State on the Title page
      the name of the publisher of the Modified Version, as the
      publisher.


      Preserve all the
      copyright notices of the Document.


      Add an appropriate
      copyright notice for your modifications adjacent to the other
      copyright notices.


      Include, immediately
      after the copyright notices, a license notice giving the public
      permission to use the Modified Version under the terms of this
      License, in the form shown in the Addendum below.


      Preserve in that license
      notice the full lists of Invariant Sections and required Cover
      Texts given in the Document's license notice.


      Include an unaltered
      copy of this License.


      Preserve the section
      entitled "History", and its title, and add to it an item stating
      at least the title, year, new authors, and publisher of the
      Modified Version as given on the Title Page.  If there is no
      section entitled "History" in the Document, create one stating
      the title, year, authors, and publisher of the Document as given
      on its Title Page, then add an item describing the Modified
      Version as stated in the previous sentence.


      Preserve the network
      location, if any, given in the Document for public access to a
      Transparent copy of the Document, and likewise the network
      locations given in the Document for previous versions it was
      based on.  These may be placed in the "History" section.  You
      may omit a network location for a work that was published at
      least four years before the Document itself, or if the original
      publisher of the version it refers to gives permission.


      In any section entitled
      "Acknowledgements" or "Dedications", preserve the section's
      title, and preserve in the section all the substance and tone of
      each of the contributor acknowledgements and/or dedications
      given therein.


      Preserve all the
      Invariant Sections of the Document, unaltered in their text and
      in their titles.  Section numbers or the equivalent are not
      considered part of the section titles.


      Delete any section
      entitled "Endorsements".  Such a section may not be included in
      the Modified Version.


      Do not retitle any
      existing section as "Endorsements" or to conflict in title with
      any Invariant Section.


    If the Modified Version includes new front-matter sections
    or appendices that qualify as Secondary Sections and contain no
    material copied from the Document, you may at your option
    designate some or all of these sections as invariant.  To do this,
    add their titles to the list of Invariant Sections in the Modified
    Version's license notice.  These titles must be distinct from any
    other section titles.

    You may add a section entitled "Endorsements", provided it
    contains nothing but endorsements of your Modified Version by
    various parties--for example, statements of peer review or that
    the text has been approved by an organization as the authoritative
    definition of a standard.

    You may add a passage of up to five words as a Front-Cover
    Text, and a passage of up to 25 words as a Back-Cover Text, to the
    end of the list of Cover Texts in the Modified Version.  Only one
    passage of Front-Cover Text and one of Back-Cover Text may be
    added by (or through arrangements made by) any one entity.  If the
    Document already includes a cover text for the same cover,
    previously added by you or by arrangement made by the same entity
    you are acting on behalf of, you may not add another; but you may
    replace the old one, on explicit permission from the previous
    publisher that added the old one.

    The author(s) and publisher(s) of the Document do not by
    this License give permission to use their names for publicity for
    or to assert or imply endorsement of any Modified Version.

    5. COMBINING DOCUMENTS

    You may combine the Document with other documents released
    under this License, under the terms defined in section 4 above for
    modified versions, provided that you include in the combination
    all of the Invariant Sections of all of the original documents,
    unmodified, and list them all as Invariant Sections of your
    combined work in its license notice.

    The combined work need only contain one copy of this
    License, and multiple identical Invariant Sections may be replaced
    with a single copy.  If there are multiple Invariant Sections with
    the same name but different contents, make the title of each such
    section unique by adding at the end of it, in parentheses, the
    name of the original author or publisher of that section if known,
    or else a unique number.  Make the same adjustment to the section
    titles in the list of Invariant Sections in the license notice of
    the combined work.

    In the combination, you must combine any sections entitled
    "History" in the various original documents, forming one section
    entitled "History"; likewise combine any sections entitled
    "Acknowledgements", and any sections entitled "Dedications".  You
    must delete all sections entitled "Endorsements."

    6. COLLECTIONS OF DOCUMENTS

    You may make a collection consisting of the Document and
    other documents released under this License, and replace the
    individual copies of this License in the various documents with a
    single copy that is included in the collection, provided that you
    follow the rules of this License for verbatim copying of each of
    the documents in all other respects.

    You may extract a single document from such a collection,
    and distribute it individually under this License, provided you
    insert a copy of this License into the extracted document, and
    follow this License in all other respects regarding verbatim
    copying of that document.

    7. AGGREGATION WITH INDEPENDENT WORKS

    A compilation of the Document or its derivatives with other
    separate and independent documents or works, in or on a volume of
    a storage or distribution medium, does not as a whole count as a
    Modified Version of the Document, provided no compilation
    copyright is claimed for the compilation.  Such a compilation is
    called an "aggregate", and this License does not apply to the
    other self-contained works thus compiled with the Document, on
    account of their being thus compiled, if they are not themselves
    derivative works of the Document.

    If the Cover Text requirement of section 3 is applicable to
    these copies of the Document, then if the Document is less than
    one quarter of the entire aggregate, the Document's Cover Texts
    may be placed on covers that surround only the Document within the
    aggregate.  Otherwise they must appear on covers around the whole
    aggregate.

    8. TRANSLATION

    Translation is considered a kind of modification, so you may
    distribute translations of the Document under the terms of section
    4.  Replacing Invariant Sections with translations requires
    special permission from their copyright holders, but you may
    include translations of some or all Invariant Sections in addition
    to the original versions of these Invariant Sections.  You may
    include a translation of this License provided that you also
    include the original English version of this License.  In case of
    a disagreement between the translation and the original English
    version of this License, the original English version will
    prevail.

    9. TERMINATION

    You may not copy, modify, sublicense, or distribute the
    Document except as expressly provided for under this License.  Any
    other attempt to copy, modify, sublicense or distribute the
    Document is void, and will automatically terminate your rights
    under this License.  However, parties who have received copies, or
    rights, from you under this License will not have their licenses
    terminated so long as such parties remain in full
    compliance.

    10. FUTURE REVISIONS OF THIS LICENSE

    The Free Software Foundation may publish new, revised
    versions of the GNU Free Documentation License from time to time.
    Such new versions will be similar in spirit to the present
    version, but may differ in detail to address new problems or
    concerns.  See http://www.gnu.org/copyleft/.

    Each version of the License is given a distinguishing
    version number.  If the Document specifies that a particular
    numbered version of this License "or any later version" applies to
    it, you have the option of following the terms and conditions
    either of that specified version or of any later version that has
    been published (not as a draft) by the Free Software Foundation.
    If the Document does not specify a version number of this License,
    you may choose any version ever published (not as a draft) by the
    Free Software Foundation.

    How to use this License for your documents

    To use this License in a document you have written, include
    a copy of the License in the document and put the following
    copyright and license notices just after the title page:


      Copyright (c)  YEAR  YOUR NAME.
      Permission is granted to copy, distribute and/or modify this document
      under the terms of the GNU Free Documentation License, Version 1.1
      or any later version published by the Free Software Foundation;
      with the Invariant Sections being LIST THEIR TITLES, with the
      Front-Cover Texts being LIST, and with the Back-Cover Texts being LIST.
      A copy of the license is included in the section entitled "GNU
      Free Documentation License".


    If you have no Invariant Sections, write "with no Invariant
    Sections" instead of saying which ones are invariant.  If you have
    no Front-Cover Texts, write "no Front-Cover Texts" instead of
    "Front-Cover Texts being LIST"; likewise for Back-Cover
    Texts.

    If your document contains nontrivial examples of program
    code, we recommend releasing these examples in parallel under your
    choice of free software license, such as the GNU General Public
    License, to permit their use in free software.
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2015-09-27 22:09:29 CEST
</div>
</div>
</body>
</html>